<p>Hello and welcome to the Unreal Engine blueprints best practices tutorial. My name is Thomas and today we will have an introduction to objectoriented programming practices. We will talk about inheritance composition with components and interfaces. If you don&#39;t understand this subheading, it&#39;s fine. This tutorial is for you. What does this tutorial teach? The goal of this tutorial is to introduce you to object-oriented programming practices. But the objective of this tutorial is to teach you implementation. More specifically, how to share common functionalities between classes. You will learn not only how to implement a functionality, but also why and when it should be implemented. This tutorial wants to teach you how to add or create a new functionality without having to fix the existing ones. Where one game mechanic doesn&#39;t clash with the ones you made before. You might work on your game and then you watch a tutorial to add a new game mechanic, but you have to fix the things you made before and rearrange the implementation or the code for that new game mechanic to work. The focus is not what the code does. The focus is where to put the code, which class is responsible for that code and what the code affects. The focus of this tutorial is theory. The focus of this tutorial is theory. Treat this video as a lecture. We use presentation to explore the theory part and the Unreal Engine program for prototyping demonstrations. There are a lot of practical examples but the emphasis is on understanding concepts. I will prototype a lot. I will change code a lot to showcase different methods of implementations. What happens when we do X? Then change the code to see what happens when we do Y and then change the code again to see what happens when we do Z. Because of that, don&#39;t follow this tutorial step by step. You can even watch it at two times speed if that is your pace. Treat this video as a lecture. Maybe grab a popcorn and enjoy. Firstly, we will cover inheritance. We will learn the difference between monomorphic and polymorphic methods. We&#39;ll learn about abstract classes, what they are, how to create one, and why they are important. We&#39;ll learn about casting. We&#39;ll explore it as a bloopin communication. Uh how it works alongside inheritance. How the actor class hierarchy works and we will explore the role of an abstract parent class with casting. Abstract class and casting work closely with inheritance. And abstract classes and casting work together. We&#39;ll learn what is a relationship means, what are related and unrelated classes, and how to design a class hierarchy using inheritance following the is a relationship. When we learn about how to create a class hierarchy, we&#39;ll look at the polymorphic example where we create a class hierarchy for interactables using is a relationship and then monomorphic example where you create a class hierarchy for hazards using is a relationship. Lastly, we&#39;ll learn about drawbacks when using inheritance. For composition, we will talk about what it is, how to work with components, and we will recreate hazards as unrelated classes with using components. We&#39;ll learn what has a relationship is, what it means, and we will compare has a relationship with is a relationship. For blueprint interfaces, we&#39;ll explore it as a blueprint communication. We will recreate interactable actors as unrelated classes using blueprint interface. And we will compare blueprint interface and casting as blueprint communications. And lastly, we will add a vehicle as a new player controlled pawn that is unrelated to player characters. A lot of times tutorials are just using thirdp person character example. But this tutorial wants to teach you how to add or create a new functionality without having to fix the existing ones where one game mechanic doesn&#39;t clash with the ones you made before. I don&#39;t just want to work with the characters or the BB third person character example. I want to add another unrelated player controlled pawn class that still needs to work with pickups and hazards. That new classes will be vehicles from the Unreal Engine vehicle example. But uh because vehicles and characters are unrelated classes, we cannot use inherited to share common functionalities between them. So we need to use components to share monomorphic events between these unrelated classes and interfaces to share polymorphic events between these unrelated classes. Using components and interfaces, we can share common functionalities between two unrelated player control pawn classes of vehicles and characters. This table and this flowchart are all that we need to create a common functionality to share between classes. The table explains how to implement a functionality and the flowchart explains when and which implementation we need to use. We need to know theory to understand this flowchart. I need to create a common functionality. Is this common functionality shared between different class hierarchies? Theory is important. We need to understand this question to answer it. We need to understand what class hierarchy is, how to create one. We need to identify if the functionality we are creating is contained in one class hierarchy and we need to know how to create a class hierarchy that follows the is a relationship. We also need to know what unrelated classes, what are monomorphic methods and what are polymorphic methods. We need to know theory to follow this flowchart. And this theory will be covered by this tutorial. This tutorial was made as part of a college project and I&#39;d greatly appreciate your feedback. After finishing the tutorial, click the link below for a short anonymous survey that only takes a few minutes to complete. Thank you for your time and feedback. So, how this tutorial came about? I wanted to see what are the best programming practices with blueprints and usually we get this kind of answers. Organize and comment your code. Avoid event tick. Avoid ascent dependencies. Don&#39;t use get all actors or class. Use inheritance instead of duplicating actors, use blueprint interface communication instead of casting blueprint communication. Many users in the Unreal Engine community ask for the best practices and receive Unreal Engine ccentric answers. If they don&#39;t have any prior programming experience, they often miss the core principle. And that core principle is already a best programming practice with blueprints. Let&#39;s look at what blueprint visual scripting actually is. The blueprint visual scripting system in Unreal Engine is a visual programming language that uses a node-based interface to create gameplay elements. As with many common scripting languages, you can use the system to define object-oriented classes or objects in the engine. The system along with the objects you define are often referred to as just blueprints. So what are the best practices with blueprints? We already found out that blueprint visual scripting language is an object-oriented programming language. So the best practice when programming with blueprints is to follow the same object-oriented programming principles you would use in any other object-oriented programming language like Java or C++. In this tutorial, we will learn three object-oriented programming principles. Those are inheritance, composition using components and interfaces. These three principles will enable us to share functionalities between classes and prevent code duplication. They will also help us create scalable and easily upgradeable functionalities. First, we will have a brief introduction to objectoriented programming. Object-oriented programming is based on the concept of objects. Objects can contain data and code. Data is in the form of fields, often known as attributes or properties. Code is in the form of procedures, often known as methods. Now, blueprints don&#39;t use the word fields or attributes or properties. We use the word variables. So, in the blueprints, data is in the form of variables. And the code, we don&#39;t use the words procedures. Uh blueprints just use events and functions. So, in the blueprints, code is in the form of events and functions. Now I actually use the word methods when referring to events and functions. So whenever I say that some method does something, I&#39;m referring to an event. For an example, when I say this method is too complicated, I&#39;m just saying this event is too complicated. Let&#39;s see how the object looks like in the Unreal Engine blueprint class. Object is a simplest class that only holds data and code. We won&#39;t be working with objects, but we can see that they already have data in the form of variables and code in the form of events and functions. We also have an event graph where we implement our variables, events, and functions. And the event graph is a place where we put our code and program. Next, we have components. Components are objects that we can add to actors. Components have the same three things. They have variables, events, and functions, and an event graph where we can place our code and program. We will work with custom actor components and actually program with them. Lastly, we have actors. Actors are objects that we can put into the level. They also have a construction script and more importantly a component window. Actor uses components to assemble modular and reusable chunks of functionality. We have components for rendering like static mesh and skeletal mesh where we define the 3D model that would actually be a visual representation for that actor in the level. In this example, we have a static mesh for rendering a visual representation of this actor. Example, there are many different built-in components like for movement, character component, projectile component, floating pawn movement component, so on and so on. There are light components like point light, direct light, skylight, so on and so on. There are many different components that are already built in the Unreal Engine that we can just add to actors, but also we can create our own custom logic with custom actor blueprint components. Components are building blocks that we can add to any actor. We can also program with actors using variables, events, and functions uh by placing them in the event graph. Let&#39;s see what happens if a beginner gets a task to create three pickups. a health pickup, a coin pickup, and a cupcake pickup. Every pickup needs to have a spinning animation, and every pickup needs to get destroyed when the player collides with them. But each pickup gives something different to the player. Health pickup gives 50 health to the player. Coin pickup gives one gold to the player, and cupcake pickup gives 100 score to the player. So, let&#39;s see how a beginner would complete this task. So we have uh a task to create three simple pickups. All pickups need to have a spinning animation. All pickups need to get destroyed when player picks them up. And all pickups need to give something. Health needs to give 50 health to the player. Coin one gold to the player and cupcake 100 score to the player. So first what we need to do is create those three variables in RB% character health gold and score. With the event think we will uh display those variables. So now in BPcoin we have the code for spinning animation and then uh we cast to the third person character on collision. We cast to the third person character and give one goal to the player and destroy the actor. By cupcake the same thing but we now give 100 score to the player and for BP health it&#39;s all the same thing. Spinning animation on collision we cast and then give 50 health to the player and destroy the actor. So let&#39;s look at how this looks. So all all of the pickups have a spinning animation and when we collide them with the gold we have with the coin we get one gold with the health we get 50 health and with the score we get 100 score. So everything now works. Now the first problem is that uh we copy and paste the code on all of these three actors. The only difference in the code is the changing the value of BP to present characters variables. This is those red squares and all of the pickups create a hard reference because we are casting to the BP Tuserson character base. So let&#39;s look at hard references first. Hard reference is where actor A refers to actor B and cases actor B to be loaded when actor A is loaded. In our example for BPcoin where BPcoin refers to BP third person character AK casts to BP third person character and causes the BP third person character to be loaded when BP coin is loaded. BP% character doesn&#39;t even need to be loaded into the level. It&#39;s still loaded into the memory just because BPcoin is loaded. So let&#39;s look at this in our uh Unreal Engine. Let&#39;s right click on BPcoin and open up size map. As we can see the pendants to display all for the memory size. BPcoin references BP thirderson character which has 110 megabytes. meaning that BPcoin also will load into memory 110 megabytes. We can see that in our reference viewer as well. If we uh show uh dependencies for our BPcoin, BPcoin is dependent on static mesh coin. That&#39;s because we need to load the 3D model so we could render render it in our pickup. And we also need to load BP third person character because we are casting to it. And we are trying to affect uh uh the gold variable that resides in the BP third person character uh class. Imagine how can we add one to the gold variable that resides in the BP% character class if the BP third person character class is not loaded. We cannot. So we have to first load the BBS character class so we can access the gold uh variable and set it as we want. Okay. So now we have done with the hard references uh for now. This is a bad thing actually that the coin loads a 110 megabytes into the memory because it loads the character. But let&#39;s say that&#39;s fine for now because right now we are loading this uh class just by game mode. So for now it will the character would be loaded when we press play. Now let&#39;s go to our other problem. The only difference in the code is changing the values of BP and character variables. Meaning all of this code is basically duplicated. It&#39;s the same code just this uh affecting the variable is different. So uh our problem in our pickups is code repetition. So our solution could be code reusability. Inheritance could be our solution. So let&#39;s look at the definition. Inheritance is a fundamental concept of object-oriented programming that enables a new class to inherit the properties and methods of an existing class. This feature promotes code visibility and creates a parent child relationship between classes. Okay, so let&#39;s break that down. Inheritance promotes code visibility and creates a parent child relationship between classes. So that&#39;s the the two main things that we need to know. So let&#39;s look at our problem. We have this uh three duplicated classes. And as you can see uh all all things in the red square are just duplicated code. The inheritance solution for that is creating a parent class and putting all of the duplicated code in the parent class. Then parent class can pass down this duplicated code to all of the child classes. and child classes can just only uh concentrate on the specific things that they need to do. Let&#39;s look at this in action. I will copy all of this code from the BP uh coin and go to the uh second folder which will create our parent child relationship and pickups used using with inheritance. So let&#39;s create a new blueprint class and uh this will be an actor and I will call this BP pickup base. This is a base class, a parent class to all of our pickups. In here, I will add a static mesh component for wizzle representation and sphere collision component for detecting collision. And I will not define the static mesh right here. This is a base class. I will just go to the event graph and paste the code. Now, let&#39;s look at what we need to do. Uh, we need to have a spinning animation here. Okay, that&#39;s this begin play. We need to cast to the player character and destroy actor on pickup. So basically we are deleting uh only the setting the health variable. All of this is in all of our pickups. These are this is the code that all of the pickups share. So we will now put it in BPA basease. So let&#39;s compile and save this. And the viewport pickups are actually a bit over the ground. So let&#39;s do this in our BBPase. I think that uh static mesh will be 40 and sphere collision will be 60 above the ground. So let&#39;s compile and save. Now we need to create our child classes. We can do that by going to the parent class, right click and create a child blueprint class. In here we will call this first one BP pickup coin. We will open it up and for visual representation static mesh we will choose that as our static mesh coin. Now let&#39;s create other two. Let&#39;s look at what we have now. In BPA base, we have this. We have two methods. On begin play, we have a spinning animation and on component begin overlap, we are handling the collision with our spill collision component where we casted the BB person character and destroy the actor. All of these functionalities are in our BBPA base, our parent class. Now, child classes, the BBP pickup coin, as you can see, has a parent class for BB pickup base, same as health and same as cupcake. They only inherit begin play and on component begin overlap. Meaning they will have this functionality even though they don&#39;t have that code in it because they inherit this functionality from the parent class. Let&#39;s test and see if that happens. If they inherit the begin play, they should inherit the spinning animation and on component begin overlap, they should be destroyed if the player collides with them. So let&#39;s press play. As we can see all of the pickups are spinning and also if player collides with them they get destroyed even though there is no code for that in the child classes. They inherit all of that from the parent class. Now uh I want to show you something uh right quickly. We can actually see that there is uh an event being in play in the BB coin that calls up the parents begin play which is a spinning animation. We can try and disconnect that for a second. This is something called what&#39;s called overriding. And let&#39;s press play. As we can see, coin is now not spinning because it doesn&#39;t inherit the parents event begin play, which is a spinning animation. Okay, let&#39;s now connect this back because uh all of the pickups need to actually have the spinning animation. Now we have this code where BB pickup coin just uh inherits the begin play and on component begin overlap. Let&#39;s try and create our own event. Let&#39;s try and create on pickup event which will print string that uh player has picked up a pickup and which all of the child classes will just inherit. Now this uh let&#39;s create a custom event and I will call this on pickup. Uh and uh this event will be called uh when player collides with the pickup. And for pickup we will print string. You have picked up a pickup. Okay. So we have code right here. Now this is a something what we can call a common functionality with same implementation where event is created in one class in our parent class and code for that event is also implemented in that same class. Uh this is a monomorphic event and all of the child classes will inherit this on pickup as well. As you can see on pickup print string they will all inherit this. So let&#39;s try and collide with our child classes. If we collide with the coin, you have picked up a pickup. With the health, you have picked up a pickup. And with the cupcake, you have picked up a pickup. So, all of the child classes just inherit that on pickup event. There is no uh code uh for this on pickup event in the child classes because they all inherit uh the implementation for for the on pickup event from the parent class. And hence why is this called common functionality and same implementation? that same implementation is in that parent class. Now, it&#39;s nice that we can print the to the player, hey, you have picked up a pickup, but it would be better if we could print what kind of picked up pickup he actually picked up. Uh, is it held, a coin or car, or cupcake? For that, we need to use a common functionality with different implementation. Let&#39;s look at the diagram. We can create on pickup in uh one class but uh put the code for that implementation in multiple different classes. So let&#39;s look at this. So common functionality with different implementation. This is a polymorphic event. Event is created in one class but the code for that event uh is implemented in multiple different classes. So basically our child classes will inherit this on pickup event and it will print string for coin you have picked up a coin pickup for health uh your health pickup and for cupcake a cupcake pickup. Now uh this code for that event is implemented in the child classes inheritance is called overriding. So let&#39;s go to the BP pickup coin and in the functions we can just click on override and then select on pickup and uh we want to have an implementation that will print string what kind of pickup uh player picked up. So this will be a coin pickup. As you can see each child class now overrides uh uh each each child class now overrides on the pickup event. Overriding event means that you provide a new implementation for each child class that was originally created in the parent class. As you can see event on pickup is created in the parent class but the implementations are uh but they are actually implemented in the child classes. So let&#39;s see if this works. So we collide with the coin. You have picked up a coin pickup. You have picked up a health pickup. You have picked up a cupcake pickup. Now we have the code for the on pickup event in the child classes. They all have different implementations for what that event on pickup actually does and hence why it&#39;s called common functionality with different implementations. Now let&#39;s create an implementation where uh each pickup can manipulate BP third person characters variables. Meaning we can actually create the functionality that we have at the beginning that health gives 50 health uh coin gives one gold and cupcake gives score 100 score. So let&#39;s do just that. And now let&#39;s see this again. This is now also a common functionality with different implementations where event is created in one class in the parent class but code for that event is implemented in multiple different classes where each child class can define what that event on pickup actually does. So let&#39;s test this now. Oh, we have to play in editor. So, see what BP health has wrong. Oh, we need to connect to the target. Okay, let&#39;s test this now. So, we will collide with the coin and we got one gold. We will collide with the health and got 50 health and we will collide with the p cupcake and we will get 100 score. So, now everything uh works. Okay, now let&#39;s look at our diagram. We have these parent class and all of these are child classes. We know that they are child classes because we have an arrow pointing to them from the parent class. When we read what parent class functionality it has. It has begin play and on component begin overlap. We can actually conclude that child classes will inherit those functionality. We don&#39;t need to outright say it or write it down because that&#39;s how inheritance works. Child classes inherit functionalities from the parent class. So we don&#39;t actually need to just say what they inherit. We can read begin play on component begin overlap and just conclude that they have uh that as well because they inherit these two events these two functionalities. Then we can just say what they override. So don&#39;t pick up uh pickup coin overrides uh on pickup and gives one go to the player. Okay, this is a parent class and parent class in this case is a base class. That&#39;s why I called it baby picka base. It&#39;s a base class for all of our pickups. Base class should only hold things that all child classes will inherit and use. Uh now for an example, BB pickup base holds all of the things that BP pickup needs or or all of the pickup needs. Spinning animation, handling collision, casting to the BB tresent character and getting destroyed on collision. When I want to create a child class from BBP pickup base, I know in advance that I am creating a pickup. I expect it uh to have all of the things that all pickups should have. Child classes should be specialized version of the parent class. All of the functionalities that are specific for for each of the child classes is implemented in the child class. In this case, it&#39;s defining a rhythm model on a static mesh component and overriding on pickup event where each uh implementation is specialized for each class. BB pickup coin gives one goal to the player, health 50 health and cupcake 100 score. Now uh let&#39;s look at it this way. All of the functionalities that are specific for all pickups should be implemented in BPA base aka spinning animation and handling collision. They use common functionality with same implementation where event is created in the parent class and also implemented in the parent class as I said that would be that uh event begin play which has spinning mission and handling collision with the on component begin overlap. Okay. Uh next uh next we have uh all functionalities that are specific for each pickup is implemented in that pickup. They use use common functionality with different implementations where event on pickup is created in the parent class but it is implemented in child classes where each child class can define what that on pickup event actually does. So on component begin overlap when a player uh collides with the child instance class and calls up the on pickup. Uh BP pickup coin defines that it should give a one goal to the player. BB pickup health defines on pickup that should give 50 health to the player and cupcake that it should give 100 score to the player. Okay. Now lastly I want to just say that uh not we don&#39;t uh shouldn&#39;t only look at methods I mean events and variables and functions. We should also look at statish components. Now in BPA basease static mesh is not defined as we can see right here. If I go to our uh folder with pickups inheritance, BPV pickup coin has a static mesh of coin. Uh we can see right here, but BP pickup base doesn&#39;t have anything. And uh we define the static mesh in our chart classes. Now this is uh for something that we will talk about later. But I just want to put now this seed that we always need to think about components when doing with inheritance especially. Now let&#39;s add score for all of our pickups. So, uh, BP health needs to give 50 health, but also needs to add score. Same thing as BP coin. So, let&#39;s try and do just that. So, let&#39;s test this. Now if we uh collide with the coin we should get score of 20 with the health score 10 and with the cupcase score 130. So now everything works. But as you could see we needed to go separately to BP pickup coin and BP pickup health to add that score. Now the question is what if we had 20 different pickups? We would need to go to each of those pickups and copy and paste this score uh score code. Basically, we still have a problem with code repetition. We followed those quote unquote rules for creating a class hierarchy with inheritance, but uh each child class still needs its own code because each pickup will give different score based on that pickup. For an example, BB pickup held gives 10 score while coin gives 20 uh 20 score. Now, let&#39;s see what the problem is. Beginners usually ask the when creating a new functionality, they ask themselves what does the functionality do? For an example, what does a BP pickup functional BP pickup coin functionality do? It gives one call to the player. So they put the code for the giving the coin pickup in the BP pickup coin. This is a duplicated ticket class and this is a child class. But uh the point still stands. They give that gold in the BP pickup coin. Now here&#39;s a new rule that we will implement. Uh uh there is a rule uh in object-oriented programming that we should protect the internal state of an object from external modification. There&#39;s a tendency that object should only be manipulated through the object itself. And basically the code that manipulates the specific actor should be in that actor or more generally the code that manipulates the specific class should be in that class. Let&#39;s now look at this again. What does a BP co pickup coin functionality do? It gives one goal to the player. So, let&#39;s put the code for the uh coin pickup in the BP pickup coin. We shouldn&#39;t only ask ourselves what does it do. We should ask actually ask ourselves what does it affect? What does a BP pickup coin functionality affect? It affects the BP third person characters variable. So let&#39;s put the code in the BB third person character and not only for the coin. Let&#39;s actually ask ourselves what does a BB pick a base functionality effect? It affects the BP third person characters variables of health, gold, and score. So let&#39;s put the code in the BP third person character. So we will now need to have some kind of requirements. The code needs to be in BP third person character because that&#39;s what it affects. The code needs to be in one place place. That way, if you want to make a change that affects all of the pickups, we can do it easily. And the code that uh needs to be accessible in other blueprints. If the code is in the BB third person character, other blueprints need to need a way to call this functionality. So to fulfill all of these requirements, we need to create an event or a function in the BB third person character class. And that event can be uh will be in the BB third character. The code will be in that event. And most importantly, events can be called from other blueprints. For an example, BP pick a base. So let&#39;s do just that. So now we need to in BP 30% character uh class, we need to create a new custom event. And I will call this pickup manager something like that. Okay, we need to have three inputs. First one will be health and then golden score. So this is what we have. New health is current health plus some input. Gold is current gold plus some input. and score is current score plus some input. Now in the BP picker base we will need to create three variables. This will be uh health value uh gold value and score value. And of course health will be a float and gold and score will be integers. Now we have created an event that uh we can now called when we cast to the BB% character base because that&#39;s the event that resides in there. So let&#39;s now call this event. So in here we&#39;ll just call up pickup manager. This is a simple event. And for our health, gold and score, we will uh input this health value, gold value, and score value. So, let&#39;s put them like this. Now, right now there is uh we will delete all of this event on pickup because we deleted it in the parent class because now we don&#39;t need it. Right now there is no code in the uh child pickups. So we can uh how can we now define the values uh for BB pickup coin that gives one gold or health that gives 50 health and so on. Now remember child class inherit everything from the parent class. They will inherit those variables as well. In the parent class we have default values which are which are basically health zero, gold zero and score value are all zero. But in the child classes we can change that all of the functionalities that are specific for each child class is implemented in the child class. So we can actually instead of overriding on pickup event and then implementing it in child classes we can just override the values of variables in this case health value, gold value and score value. So let&#39;s go in the child class BP pickup coin. We can go to the class defaults and we can see that we can actually define specifically what values of health golden score will BP pickup coin have and for gold value it will have one airon score value will have 20. For BBP pickup health it will have health value of 50 and score value of 10. And for the cupcake it will have just have a uh score value of 100. As you can see, there is now no code in our child classes. We are just defining or overriding the uh default variable values in our child classes. And that&#39;s that specialization for our child classes. So let&#39;s test this. So we have health z uh gold zero score zero and now we have gold one score 20, health 50 score 30 and score 130. cups basically follow the rule of common functionality with same implementation. There is no code in our child classes. All of the code is in the parent class. Uh basically because we were affecting the uh burp% characters variables, we override variables in our BBPase. Uh because we are just dealing with the value of variables. We are overriding variables and we are not overr over overriding events like we did in our previous examples. Now I want to add a new thing to just show this uh power of inheritance. Now pickups only have spinning animation as we can see right here. I also want to add a floating animation. So let&#39;s do just that. Okay, let&#39;s now test this. And as we can see, we have both rotating and floating animations. And we only needed to implement this in the parent class because we want all of the child classes to implement this rotating and floating animation. Now uh let uh let&#39;s see uh right now we just have health, gold, and score value. What if we want to add another value? Now this will be just an example. I&#39;m actually perfectly fine with just having these three. But just uh no, let&#39;s see how we can actually add a new value. Right now, every pickup can give uh some value of health, gold, and score like we can see here or in our default values. What if we want to add one more value that pickup can give? Uh for so first, let&#39;s add for an example a pickup message that could show the player that every time he picks up a specific pickup. First what we need to do is uh actually go into the BP third person character and from there uh create a new variable because this will be affected a new variable. Let&#39;s call this a pickup message which will have a string and pickup manager will have another input of pickup message which will also be a string. Now there are no additions in here. We will just set a pickup message as an input. And now in the BP pickup base, we need to create a pickup message value. What&#39;s the value of pickup message for each of those pickups? And let&#39;s connect it right here. Oh, pickup message value needs to be a string as well. And now we can go uh we can go to BB pickup coin and actually define what the message value is. You have picked up a coin pickup. Let&#39;s say that&#39;s the message value for health will be health. And for cupcake of course cupcake. Oh no. And now uh in BP% character we actually have to display that as well. So I will do just that. Let&#39;s go here and this will be message last pick up pickup. Okay, let&#39;s now test this. So last picked up pickup is a coin. Last picked up is a health and last pickup is a cupcake. Now as I said this was just an example how we can add another value. I will not actually hold this uh pickup message anymore. So we will now just still have just health gold and score. But this was just to showcase how we can add uh a new value with our pickups. Now we have succeeded in another thing. Let&#39;s see how we can add another pickup. Now, all we have to do is uh let&#39;s say that we have uh we are programming and we have a friend a friend that likes to create 3D models. He doesn&#39;t know how to use blueprints. We need to make it uh the code in such a way that he can actually implement the pickups without knowing how to create code. We have done that just right now. So if you want to create a new pickup, we just need to create a child class from BP pickup base. Name it define a static mesh and input values in the class defaults. Designer doesn&#39;t even need to know how pickups actually work. Spinning animation, pickup logic, sender data, destroying on collision. All of the logic is hidden in base class. That&#39;s why BP pickup coin doesn&#39;t have any code or any other child classes have any kind of code. So let&#39;s do just that. Let&#39;s add new pickups. So we have to go create child from blueprint class and this will be BP pickup burger. Let&#39;s open it up and define a static mesh which will be a burger. It&#39;s not as burger. Let&#39;s compile and save. And now in the class defaults burger is a score pickup. So I will just give 500 score. Compile and save. Let&#39;s add another pickup. Let&#39;s say friend now created us a static 3D model of a cone pouch which would be a gold pickup. So all he have to has to do is in BP pickup base create a child looping class and this will be BP pickup coin pouch. He will also need to define a static mesh such as SM coin pouch. position it in here and then in the class defaults say that the gold value will be 10 and score value 100. Compile and save. And now let&#39;s add these two pickups into the level. Let&#39;s add BP pick a burger and coin pouch. And let&#39;s press play. If we pick up burger, we should get 500 score. And with the coin pouch, 10 gold and 100 score. So 600. As you can see, everything works. And of course, everything from before still works. So that&#39;s how we can add new pickups. Let&#39;s talk about abstract classes. Abstract class is always a parent class and it needs to be defined as an abstract class. So it cannot be instanced into the level. This just means so we cannot put it into the level. Now uh BPPA basease should be an abstract class but we never defined it as such. So right now I can actually put BPA basease into the level. But as you can see this is an a pickup with no visual representation. I cannot even see it into the level. And if I press play I cannot really see it. If I even succeed in colliding with this BP pickup base, I will get its default values from variables which is basically health. Health health value is zero. Gold value is zero. Score value is zero. Pick a message value is none. So basically I get nothing. I cannot see it. It&#39;s nothing. The abstract class should only hold components, variables, and methods. It shouldn&#39;t have any kind of visual representation. Now uh let&#39;s now generate this as an abstract class. We can go to the class settings and just check check on generate abstract class. Compile and save. Now I will try and put this into the level. As you can see I cannot put this into the level. I can try spawn actor from class and start typing BP pickup base. Nothing. There&#39;s none because this is an abstract class and we frankly don&#39;t want to put an invisible uh actor into the level that gives nothing. BPPA base is an abstract class. An abstract class should only hold components, variables, and methods. it. Now this first rule is just a rule basically for a parent class. It should hold all things that child classes will inherit and use. So it holds uh sphere collision component for detecting collision. It call static mesh component uh but it doesn&#39;t have it anything defined. Child classes actually define the static mesh component for its visual representation and it has code such as for spinning animation for casting to the be person character affecting its variables and destroying an actor. basically all of the pickups things. And lastly, this is most important, uh, it shouldn&#39;t define anything that can load something heavy into the memory. Usually, visual representation is heavy on memory like 3D models, visual effects, sound effects, uh, and especially textures and materials that hold those textures. As you can see in BPP Capase, all of the child classes actually have the 3D model in their icons. But BP Capase doesn&#39;t. That&#39;s because we don&#39;t have uh anything defined as a static mesh. We can in the abstract class create and add a static mesh, but we should never define it. Never that something is heavy on the memory. We will look at this more closely when we&#39;ll be working with characters. Let&#39;s create uh another playable character. So player could choose between two playable characters, something like Mario and Luigi. So we can go to the third person blueprints and rename this BP third person character to BP queen. Now I renamed this car character to BP queen because that&#39;s the default skeletal mesh that this uh third person character had as you can see right here skeletal mesh queen simple. Now usually what people do is duplicate this class and let&#39;s call this BP manny and that&#39;s because in BP manny we will actually define this skeletal mesh as SKM manny simple compile save and let&#39;s look at how it looks. So this is Manny of course. Now if I press play, I am still with the queen. So everything works. But I can actually change what player player I want in the game mode override where I can select the default pawn class and select the BP Manny. And if I press play and try to collide with these pickups, as you can see, nothing happens. Actually, I&#39;m actually colliding with pickups as well. Now, first thing I want to do actually realize that there is collision between those static meshes, these 3D models. Now, I don&#39;t need to go to all of these pickups and then just say what kind of static mesh uh collision, what kind of collision needs to be in those static meshes because they&#39;re all child classes of BPA base. I can just do that in our BPA base. So we can select our static mesh component and instead of having block uh all dynamic we can just have no collision. So compile and save and press play with BP man. Now we can pass through our pickups. But as you can see we are not picking them up. So let&#39;s see why is that. And we can see right here in the code when uh on component begin overlap we cast to the BP queen which calls up a pick a manager that target is BP queen and then destroy the actor. We are not playing with BP queen. We are playing with BP Mary. So what should we do? We should technically go to uh BPA base uh to BPA base and from the cast failed cast to BP Manny. Now this uh BP man was duplicated. So uh BP Manny also has a pickup manager. So we can just call this pickup manager from here. And as you can see target is BP man while target for this is BP queen. So let&#39;s connect this from other actor. And let&#39;s test now if this works. We are not destroying actors. So we have to actually do this and test now. And now everything works. But let&#39;s look at the size map. Now if I now go to the uh BBPase and open size map, it uh it is 144 megabytes. Why is that? Because it loads BP queen and BP Manny. Now as you remember casting creates a hard reference. So when we cast to uh BP queen, it will load it into the memory so we could call its pickup manager so we could affect its values. But if that fails, we cast to the BP Manny. This is a problem. Before we had in BBPase only 110 megabytes, but didn&#39;t matter. We had uh and this BBPase would load our player character, but it didn&#39;t matter because we only had one charact playable character. But now we have two and we can only play one at a time. We can only play with BP Manny or we can only play with BP Queen. But uh if we put any of these child pickups into the level, it will load both uh BP Queen and BP Manny. Now we have one uh character that we are not playing with and it&#39;s loaded. Now that might not be a problem, but what we have 10 different characters that we could play with, but we can only play with one at a time. we would still load those 10 characters and that&#39;s a problem. So let&#39;s look at more closely what actually casting is and what we what we can do about it. So let&#39;s talk about casting. What is casting? Casting is a common communication method where you take a reference to an actor and try try to convert it to a different class. If the if the conversion is successful then you can use direct actor communication to access its information and functionality. With casting it can either be successful or it can fail. This method requires a reference to the actor in your level. So you can use the cast node to try and convert it to a specific class. This reference in this example is this other actor. And this communication method uses onetoone relationship between your working actor and your target actor. This is that right here. If we get the cast is successful, we can basically have a direct communication where we can access its casted actor variables, components, methods and so on. We have everything and we can access everything. Now what is casting really? Casting is just telling the Unreal Engine, hey, I need this specific class. Can you convert it to this that specific class? Because it can either be successful or fail. Now I need this specific class to access its specific functions and events variables and components in our BB third person character example that would be pickup manager. So let&#39;s look at this from the BP pickup basis perspective. Hey I need be uh BP queen so I could access pickup manager and uh if that fails hey then I need uh BP Manny so I could access its pickup manager. As you can see, pickup manager target is BP queen because that function resides in the BP queen uh class as we can see right here. Same thing for BP man. Now casting is a communication method where you take a reference to an actor and try to convert it to a different class. It&#39;s telling the engine that you need that specific actor and Unreal Engine loads it loads it and creates a hard reference. it needs to load that actor into memory so it can actually access its specific functions and events, variables and components. How could you do it that do that if it&#39;s not loaded into the memory? And when you want to cast to another class, both classes need to be in the same class hierarchy. Meaning both need to have the same parent class. This right here is a built-in class hierarchy in the Unreal Engine. This is basically uh the class hierarchy how it looks under the hood in the engine. First, we have an actor. Actor is an object that can be placed or spawned into the world. Basically, everything that we can see or interact in our game is an actor or child class of an actor because that&#39;s the object that can actually spawn or be placed in the world. Then we have a pawn. A pawn is an actor meaning child class of an actor that can be possessed and input and receive input from a controller. Whether that is a player controller or the controller doesn&#39;t matter. we can control it. Then we have a character. Character is a type of pawn. Basically, it&#39;s a child class of a pawn that includes the ability of it to walk around. Now, uh with casting, we are telling the Unreal Engine, I need the specific class to access its specific functions, events, variables, components. If we cast to an actor, we can access its specific things such as functions and events such as set actor location, spawn actor from class, destroy actor and so on. And because this is an object that can place or spawn in the world, uh any anything that is an actor or is a child class of an actor can use those uh functions and events. Then we can cast to a punk class to access its specific functions and events. Now pong class is a child class of an actor class. It will inherit all of the functions and events and variables from the actor class and have its specific of its own such as add control input or add moment input. Character inherits all of the functions and events and variables from pawn class and all of the functions and events and variables from the actor class. Now character uh uh can access its own specific uh functions and events such as uh components, character component, arrow component, mesh component, character movement component, uh events and so on. These are all builtin classes in the Unreal Engine. That&#39;s when we click actor, born or character. uh if we click a character we can also uh inherit and can uh access add control input or set actor location and these components. Now we can uh these are all built-in classes. From there we can actually select character and create BP third person character. In here we can create our own functions and events and variables and we can cast to BB third person character only when we need to access its specific functions and events such as pickup manager. If we need to access a character movement component, we don&#39;t want to cast to be Peter person character because character movement component is actually in the built-in class of a character. So let&#39;s now see examples. Uh now we will have both BP manny and BP queen. Uh for our examples in the level I have this BP casting example. Uh we will play firstly with BP queen. We have a code when on component begin overlap with our box collision. We will destroy an actor. Okay. This other actor uh output is just like if we cast to an actor uh built-in actor class. Even if I try to do this now, it will actually say note other actor is already an actor. We don&#39;t need to cast to it. So let&#39;s see what happens when uh we collide with BP queen uh with our BP casting example. So BP queen collides with this casting example and it got destroyed. Now let&#39;s try with BP Manny and it got destroyed. Now why is that happening? Both BP and uh Manny and BP queen are child class of a character which a child class of pun which a child class of an actor and destroy actor function is a uh a function from the built-in actor class which both BP Manny and BP queen uh inherit from. So it will work for both of them. Same thing will be with our set actor location. It will work for both of these classes because both BP Manny and BP queen inherit from the uh built-in actor class. But let&#39;s just check to see if it actually works. But it will work because as I said both BP Manny and BP Queen inherit from the actor class. Now let&#39;s go to another example. I will now try to cast to BPQ queen and from there try to access the character movement component. So I could access the set movement mode function which resides in the character movement component. So let&#39;s now try first with BP queen. And it worked. I cannot move. Let&#39;s see why is that? Because BP Queen inherits from the character class and character uh and BP queen has inherited the character movement component from the character class. It works. Now let&#39;s try with BP Manny. And as you can see, I can pass right through. I didn&#39;t uh have disabled movement mode to anything. Why is that? Well, casting is telling the Unreal Engine, hey, I need this specific class to access its specific functions and events, variables, and components. I said to annual engine, hey, I need the BP queen to access its character movement component to access the set movement mode none. I didn&#39;t ask to access BP many. So what I will need to do now if I want to access BP is many character moment component uh to set moment mode to none. I will have to from the cast failed uh cast to the BP man. And let&#39;s see if it now works. It works. I cannot move now. That&#39;s because we cast to BP man which inherits from the character class which inherits from the character movement component. Now let&#39;s see the size map of our BP casting example. It loaded both BP queen and BP Manny into the memory. Now we can only play with one character at a time. What if we had 10 different characters and wanted to have the functionality right here. We would need to cast failed to other character, cast fail to other character 10 times. And let&#39;s say that each character has 80 megabytes of memory. we would load 800 megabytes of memory of character into the game. Uh, but we can only play with one. Now, let&#39;s think about something. What is casting? Casting is telling Unreal Engine that I need the specific class to access its specific functions and events. But if only what I need to do is access the character movement component. Both BP Manny and BP Queen actually inherit that character movement component from the parent class of a built-in class of a character. So if we need to access the character movement component, we can actually just do this cast to the built-in class of a character and then get the character movement component and set the movement mode to none. So let&#39;s now try this with BPQ. It works. And let&#39;s now try with BP Manny. It works. Let&#39;s look at the size map of our BP casting example. As you can see, it&#39;s only 120 kilobytes. It&#39;s not 100 and something megabytes because we are not casting to the BP Manny or BP Queen. Uh we are not loading BP Manny or BP Queen. We are just casting to the built-in class of a character and casting is telling the Unreal Engine, hey, I need this specific class to access its specific component. Casting to the built-in class uh character actually holds the character movement component. BP Manny and BP Queen just inherit that component because built-in character class, it&#39;s their parent class. and BP Manny and BP Queen inherit everything from the built-in actor class, pawn class, and of course the character class. Uh, and we don&#39;t need to specify if it&#39;s BP Manny or BPQ. We are casting to their parent classes. That&#39;s why when we have destroy actor, set actor, they&#39;re not shown in the uh, size map. Now, there is actually another code which loads the red material. If we look at the size map right here, as we can see, uh, this is that red material. If we look at now reference viewer, you can see all of the dependencies for our BP casting example. It is dependent on the 3D model of a cone which is dependent on the white material and it&#39;s dependent on the red material because of the code that we have here. Okay, now back to the casting. Now uh BP Manny and BP Queen uh inherit from the built-in character class which means that we can access and manipulate for both BP Manny and BP queen everything that is from that built-in character class. So basically everything that&#39;s from the uh character class and it actually has a skeletal mesh component. So we can actually uh uh manipulate the skeletal mesh component as well by casting to the character class. Let&#39;s see an example of that. So in our BB casting example, we can actually cast to the character and access the skeletal mesh component and then set materials for both element index zero, element index one to material of red. So let&#39;s try and see this. And as you can see, BP Manny got red. And same thing for BPQ queen. BP queen got red as well. Now what we cannot access uh for BP man or BP queen is the uh specific functions and events and variables that BP manny and BPQ queen have. For an example pickup manager. We have this problem in our BP pickup base. We have a pickup manager that resides in BP Queen and we have separate pickup manager that resides in BP Manny. We cannot access this because they don&#39;t have this the common parent class. The first common parent class between BP Manny and BP Queen is a built-in character class in the Unreal Engine. So let&#39;s see what we can do uh about that. So the biggest problem is that BP Manny and BP Queen have a character as its first built-in class of a character as its parent class. And if you remember what we did, we actually duplicated BP Queen and BP Manny. BPQ Queen has all of this held call score and pickup message variable and so does Manny. Uh uh BP Manny has this pickup manager event and so does BPQ. Actually, all of the code and everything is duplicated. Components are duplicated. uh variables are duplicated code is duplicated. The only difference between BB queen and BP Manny is what skeletal mesh define they defined. BB queen has a skeletal mesh queen simple as defined and BP Manny has BP man skeletal mesh many simple as a defined skeletal mesh. Now let&#39;s look at this with our graph for an example. So we have in here BP manny and BP queen and they have everything uh everything duplicated. Now, if you want to cast to the uh skeletal mesh component of a character, we can just cast to the skeletal mesh of the built-in class character and we can affect both skeletal mesh man and skeletal mesh queen. Same thing as character movement components that we have in our casting uh example. Now, what happens if you want to uh access the pickup manager event for BP Manny and BP Quinn? Well, we have uh casting is telling the Unreal Engine, hey, I need this specific class to access its specific events and functions. And because BP Manny and BP Queen are technically unrelated one from another because the first pen class is the built-in class, we have to cast separately to BPQ and to BP Manny. As you can see, pickup manager target is queen. Pickup manager is target is Manny to access the duplicated events and functions. Now if you remember when we talked at first of first of the video about inheritance the simplest uh explanation is we take the duplicated things and put them in the parent class. Well we can do that just in here as well. We can just create a BP playable character base and child classes of Manny and Queen. And now BP pickup base will hold the pickup manager that our BP pickup base can cast to. And from there BP Manny and BP Queen will just inherit that pickup manager. They will inherit health code and score variables. They will inherit all of those things. The only difference is that BPQ queen uh the only specialization between these child classes BPQ will uh define the inherited skeletal mesh as SKM queen simple and BP Manny as SQM man simple. So let&#39;s do just that. And so we have now here this now we have BP playable character base uh and uh as you can see BP level character base and then BP level character uh queen and now we will open BP level character Manny. Actually, let&#39;s rename this. I have renamed this to just BP Manny and BP Queen so it can be simple to read uh in our tabs. So, we have BP level character base. This is now a parent class for our BP queen and BP Manny. Let&#39;s look at it. BP queen, parent class, BP level character base. BP Manny uh parent class BP level character base. As you can see here in the event graph, we have no code. We don&#39;t have anything in the variables but this both BP Manny and BP queen inherit everything. If I try to get health, I will get it because it inherits from its parent class BP playable character base. Now what we can do in our uh pickups uh we can now go to the BB pickup base and instead of casting both to the BP Manny and BP queen we can just cast to the parent class because parent class actually holds the pickup manager functions. BP Manny and BP queen just inherit that. So let&#39;s go cast to BP playable character base. We will call up a pickup manager function. So let&#39;s now test if this works. First we need to actually uh have BP Manny. And as we can see our pickups work. Let&#39;s now try with BP Quinn. And the pickups work. In our BP pickup base, we are casting to the BP level character base to access its own specific event which is a pickup manager. uh which manipulates the health and golden score variables. BP Manny and BP Queen are child of the BB playable character base and they inherit those functionalities. Now let&#39;s look at the size map for our BP pick. It has 65 megabytes because it references the BB level character base. It means it casts to BB level character base and it has to cast to it because it needs to access the pickup manager. But BVP playable character base has 65 megabytes because it&#39;s dependent on the skeletal mesh man simple. Let&#39;s actually look at that in our third person uh BB playable character base. So BB level character base has 65.2 megabytes. Okay, that&#39;s because of the visual representation of the skeletal mesh. Now this is a parent class. We should also uh try and uh try and uh create it or generate it as an abstract class. We&#39;ll do that in just in a second. But one rule for abstract classes is that it shouldn&#39;t define anything that can load something heavy into the memory. Usually vis representation is heavy on memory like 3D models, visual effects, sound files, and especially textures and materials that hold those textures. This is the example right here. Skele B PB level character base as an abstract class should only hold component variables and methods. It shouldn&#39;t component define anything that&#39;s heavy on the memory. So let&#39;s try and actually remove the the the the defined definition uh of the skeletal mesh component. So basically we will remove this skeletal mesh component man is simple from the BB level character base. Let&#39;s compile and save this and look at the size map right now. It is 800 kilobytes because oh we have actually anim animation blueprint in here as well. So let&#39;s actually undefine the animation blueprint as well. compile and save. And let&#39;s look at the size map. It is only 148 kilobytes. It basically has macros itself, a widget, and uh script. Okay, so basically it&#39;s nothing basically. Now uh BBPA base when cast to the uh B level character base, it will only loads 160 kilobytes. But let&#39;s now try and play with BP queen. As we can see, it works. But if you try with BP Manny BP Manny, we can see there&#39;s nothing there. Is he&#39;s invisible. That&#39;s because it actually inherited from the BP level character base that said the animation blueprint is none and the skeletal mesh is none. So actually let&#39;s just uh put this as animation blueprint Manny. And for skeletal mesh we will have SKM manny simple compile and save. And as we can see it works. Now we can accidentally actually select BP playable character base and when we press play there is no visual representation and only just holds code. So that&#39;s why we need to generate something as an abstract class so we cannot accidentally instance it into the level. So let&#39;s do just that in the class settings. We can just generate abstract class compile. Save. And now we cannot uh accidentally uh instance a BB pick up a BB playable character base as an abstract class into the level. We can only instance those things that actually have visual representation such as BP Manny or BP Quinn. Now let&#39;s look at another examples for our casting. We have BPQ base which is an abstract class that doesn&#39;t have anything of static mesh defined and it&#39;s actually generated as an abstract class. This parent class has two child classes, BPQ red and BPQ blue. Both of them don&#39;t hold any kind of code and we can actually instance them in the level. BPQ base holds a custom event interact with the cube which prints out a string. Hi, I&#39;m a cube. Now, we need to call up this event from somewhere and we will call it from the BP level character base. When the player presses an F key, it shoots up a line trace. Uh, and see, let&#39;s see what we can do with that hit actor reference from that line trace. If we first try to cast to the BP cube red and try to interact with the call up the event interact with the cube, it will print out a string hi I&#39;m a cube while blue one won&#39;t. That&#39;s because when we cast to the BPQ red, we call up this event which inherits from the BPQ base. Same thing will happen if we now try to cast to the blue one. Now the difference is only that uh if we try to interact with the blue it will work while with the red it won&#39;t. That&#39;s because we are casting to the specific class to access its specific things and functions. Now what people usually do if the cast cube to the red fails they cast to the blue cube and now both of them will work but these uh will both load be loaded into the memory and load the static meshes and the materials. What we should do is put them in the parent class and then just call up the interact with the cube which both of these classes inherit. So now both will will work as well as you can see. Now let&#39;s look at another example. Instead of having uh instead of having one uh common functionality with the same implementation, let&#39;s try common functionality with different implementations. And let&#39;s test this out. Now when we interact with the red cube, hi I&#39;m a red cube and hi I&#39;m a blue cube. Now we are calling the interact with the cube. We are casting to BPQ base and then calling interact with the cube. But when we cast to the parent class we actually get a reference from the child class. So actually we call up the overridden event uh from the uh child classes. And this is that common functionality with different implementations inter event uh interact with the cube was created in one class the pan class but code for that event is implemented in multiple different classes. For the BP cube red it&#39;s this one and for the BP cube uh blue it&#39;s this one. Okay. Now uh I will try to show you uh something that&#39;s called extending and overriding. Basically let&#39;s have that uh we have to say hi I&#39;m a cube and for pen class uh for child classes to uh extend the functionality. So let&#39;s see how we can do that. So what we have now here uh in the child class we will call event interact with the cube print this string but then we will print uh call up the parents interact with the cube which will print this string. So let&#39;s see how this works. So when I now interact with the red it will say hi I&#39;m a cube a red cube to be exact and if we interact with blue hi I&#39;m a cube a blue cube to be exact. Now when we call this interact with the cube uh it is implemented in such a way in the child classes that it will will have its own implementation but it will uh inherit parents implementation as well. Now let&#39;s create another code. Let&#39;s remove this in the child classes and actually in the parent class create a functionality where when we interact with it we set the material of the cube to white. And when we try to interact with it, we turned it to white. We turned it to white. Now, let&#39;s actually do something different. Let&#39;s make this cube uh white at the beginning and when we interact with them, turn them to red or blue. If I now try to turn this uh BPQ base, turn the material to red and try to play both of them will inherit turning to red. But I want BP cube to turn red and BP cube blue to turn blue. So what we can do is first try to override it with methods uh override the event. So in BPQ rev we can have event interact with the cube and it will have material red and for BPQ blue it will have the material of blue and as you can see now it works. But if you look at the code closely code is the same. Maybe if the code is always the same and does the same thing and affect the same thing the code sets is the set material. it affects the static mesh component and BP cube glue is the code is set material and it affects the static mesh component. The only difference is in the input. So maybe we shouldn&#39;t solve shouldn&#39;t solve this with the uh methods or event in this case but uh or overriding with events. We should override it with variables. So let&#39;s try to do that. So let&#39;s test this. The first one turned to red and the second one to blue. Everything works. There is no code in BPQ red BPQ blue. We are just casting to the BPQ base and calling up the interact with the cube and all of the code is in the base class. Now it&#39;s always better to have a common functionality with same implementation even when we have variation and specialization between two two classes this turning red and this one turning blue. Uh it is always better to override variables and then uh specialize them in the class defaults than having uh to override the methods like we have here. So now we still succeeded to have something like common functionality with same implementation event is created in the parent class and code for that event is also implemented in that parent class. But uh when should we actually use a common functionality with different implementations? We can always use that but we should always strive to overriding variables and having a datadriven design than having a method of overriding methods and having a method driven design because we will just have duplicated code with different inputs. So we should always use a common functionality with different implementations when we actually have to use it when we are forced to because we cannot find a common ground between uh two codes that does the same thing. For an example in here in the uh child classes in the parent class we have created an event uh interact with the cube but code for that event is implemented in BPQ bread such as this. At the first glance, you can see that code is totally different between the red and blue. Let&#39;s see what actually happens. The red one started jumping. And why did it start to jump? Because the blue one turned into a disco ball. So, the red one is just dancing. Now, let&#39;s see what is actually happening in the code. So, in BPQ Red, we just have a timeline which we set a relative location. Basically it&#39;s animation of jumping or dancing. But in the blue one uh and in this one we are just affecting the static mesh component by setting the relative scale. But in the blue one first we are affecting the static mesh component with a totally different code. We are changing it to the sphere sphere component. Then we have animation of rotation and the float floating. I basically stole the code from the pickups. And then every 2 seconds I am changing the material by affecting the static mesh. We are affecting the static mesh but we are uh between BP cube blue and BBQpub red but but affecting totally different things on that static mesh. This we are just setting the relative scale but it is we change the static mesh to a sphere and then we are changing the materials and of course changing the relative location rotation. This is uh the way when we should actually use a common functionality with different implementations because uh we have a common functionality of interacting with the cube but the implementation of it is totally different. We can we will look at it this uh common functionality with different implementations more closely when we&#39;ll be do when will we be doing an interaction system. So that&#39;s basically it how we should uh always cast. We should always cast to an abstract class. As you can see, I did all of those things, but I never even look at the BP level character base. I just leave the cast to BPQ base, the abstract class, and then just call up the interact with the cube. Anything else I was just doing in the parent or child classes. I didn&#39;t touch the casting or the call up the event ever again. And that&#39;s the main uh takeaway. We should always cast to abstract classes. Casting when to use it. Casting works closely with inheritance. Always cast to abstract classes. We can cast to built-in abstract classes in the Unreal Engine. We can cast to built-in actor class to get the built-in get actor location function. We can cast to built-in character class to get a capsule component or set something in the character movement component. We can cast to components themselves like static mesh, skeletal mesh, so on and so on. We can cast to any built-in abstract class in the Unreal Engine. They don&#39;t even have a hard reference because they are already loaded by the Unreal Engine itself. They won&#39;t even show up in the size map. As I said, always cast to abstract classes. We also need to cast to userdefined abstract parent classes. uh we can create an event in the abstract class and then call that event from another class. By casting to an abstract class, we can manipulate all child classes with that inherited event. Whether the child class just inherits that event from the parent class or overrides it in the child class itself. Now casting to userdefined abstract parent classes still creates a hard reference. But we can ignore it because it loads kilobytes into the memory. it loads kilobytes into the memory because we are casting to the abstract parent class that should not load anything heavy into the memory. Now the bigger problem is that casting works closely with inheritance. Uh because of that inheritance cannot share a common functionality between classes. Uh casting also becomes hard to work with. Now we have not encount encountered this problem yet because we can still share common functionalities with inheritance. Later on, we&#39;ll cover the drawbacks of inheritance. But as I said, the bigger problem is that casting works closely with inheritance. If inheritance cannot share a common functionality between classes, casting also becomes hard to work with. Casting chains become a problem when you want to share a functionality between unrelated classes. Now, we&#39;ll see what happens when we cannot work with inheritance and how casting becomes a problem. General rule is if you cannot work with inheritance then don&#39;t use casting. We have done a lot with the inheritance. We created our pickups and we created our characters so they can share functionalities between them. Now let&#39;s focus more about theory of inheritance. So the inheritance is a fundamental concept of object-oriented programming that enables a new class to inherit the properties and methods of an existing class. This feature promotes code visibility and creates a parent child child relationship between classes. Now this uh relationship part is uh really important. There&#39;s actually another way we can define relationship between classes in inheritance and that would be the is a relationship. Now uh let&#39;s say that inheritance promotes code resibility and the relationship is is a. So what is that? Uh there is a relationship also known as the inheritance relationship represents a type of relationship between two classes where one class is a specialized version of another. To simplify that child class is a specialized version of the parent class. Is a rel relationship represents a type of relationship where child class is a specialized version of the parent class. Only following the is a relationship we can properly make a class hierarchy using inheritance. So what does that mean? Let&#39;s say for an example we have a car parent class and Volvo as a child class. So Volvo is a child class of a car. We can also say that Volvo is a specialist type of the car. So we can say Volvo is a car. For another example, Ford Ford is a car. As you can see, uh it&#39;s really logical with our day-to-day thinking. Let&#39;s look at another example. We have a dog and dog is a child class of an animal. We can also say dog is an animal. We have a bird. Bird is a child class of an animal. But we can also say bird is an animal because dog is a type of type of animal. Bird is a type of animal. Ford is a type of car. Volvo is a type of car. There specialized uh specializations of their parent classes. Now these child classes can have their own child classes as well. They also need to follow the is a relationship. They also need to be the specialized type of their their parents. So poodle is a dog and dog is an animal and pigeon is a bird which is an animal. As you can see very logical way of thinking. Now let&#39;s talk about relationship between classes. Are they related or unrelated? Classes are related by inheritance. Meaning they are in the same class hierarchy. All child classes of animal parent class are related. All of these are animals and all of the child classes of car parent class are related. All of these are cars. So we can also check this if the classes are related by testing there is a relationship. Volvo is a car. That&#39;s true. Poodle is a dog. Yes, poodle is a dog. And pigeon is an animal. Yes, pigeon is a bird which is an animal. But Volvo is a bird. Nope. They&#39;re not in the same class hierarchies. And logically speaking, Volvo is not a bird. It&#39;s a car. Pigeon is a car. Nope, they&#39;re not in the same class hierarchies. Pigeon is a bird, which is an animal. And Ford is an animal. Nope, that&#39;s not true as well. Ford is a car. They are unrelated because they don&#39;t have any way the same parent class. These are animals. These are cars. So, so we just need to follow the direct parent class to find the relationship between classes. Pigeon is a dog. Let&#39;s see. Pigeon is a bird. Bird is an animal. Nope. Pigeon is not a dog. As we can see, we have to follow the direct parent classes, but they are related that they have the same parent class. Both pigeon and dog are animal while Volvo and uh animal class will never be in any way related because they don&#39;t have the same parent class anywhere in the class hierarchy. We can just take one class and compare it with another class by checking their first shared parent class. First shared parent class between a pigeon and a dog is an animal parent class. They&#39;re only uh related by being animals. Now I said that the car and the animal are totally unrelated classes. And that is true. But they actually do have a shared parent class. Uh we can just take one class, a car class, and compare it with another class, an animal class, and then we can check their first shared parent class. The first shared parent class between a car and the animal would is a built-in pawn class. Now they are both quote unquote related by having a pawn class as a first shared band class which is a built-in class in the Unreal Engine. Uh so both car and the animal inherit everything from the actor and inheriting everything from the pawn which is an actor that can be possessed and receive an input from controller whether that is a player or AI controller but they are not related. Uh they are unrelated because their first parent class is a built-in class in the Unreal Engine. We are creating a new unrelated class every time we create a new blueprint class. Basically every time we rightclick create a new blueprint class and get this window. If we pick a parent built-in parent class and choose one of those, we are creating a new unrelated class. So basically if we are checking two classes and they have first shared parent class as a built-in class in the Unreal Engine, we can consider those classes unrelated and all of those child classes those class hierarchies basically are also unrelated. Classes are only related if they have a userdefined class as a shared parent class. So let&#39;s look at this. As I said, if we are checking two classes, BP Manny and BP Quinn that have first shed parent class as a built-in class in this character, then we can consider those two classes unrelated. Okay, so let&#39;s uh let&#39;s look at this example. Uh we have BP Manny and BP Queen and they are unrelated. If you want to access the pickup manager in BPQ and pickup manager in BP Manny, uh I would need to cast to both those classes separately. Now I can cast the built-in character class and manipulate this their skeletal mesh or character movement component because those that&#39;s the those are two components that BP man and BP queen uh inherit from the built-in character class. But I cannot access anything that is userdefined like pickup manager and variables health golden score. In the right example we have BP Manny and BP Quinn which are related. All of the user definfined methods and variables aka pickup manager and variables held colon score uh are stored or are held in the BP playable character base. Now I can just cast to the BP playable character base to access the pickup manager function. Uh and uh that will uh that will affect the instances of the child classes that I&#39;m currently playing with. If I play with the BP Manny and the cast is the BB level character base, Manny will inherit those functionalities. In this case, if we are checking two classes and the first shenan pen class is uh userdefined, it is the create it was created by the programmer by choosing the character class and then uh that was made as an abstract parent class and all of the child classes inherit from it. Then those two classes those classes are actually related because classes are only related if they have a userdefined class as a shared parent class. And as you can see we can have many different families uh of classes that uh they inherit from the specific parent class. Now the first one is usually a base class. The base class inherits usually from the built-in parent class with actor uh pawn character so on and so on. But uh these classes as you can see unrelated. Uh animals are its own uh rel related classes. Cars are their own, pickups are their own, characters are their own, interactables are their own, hazards in the level are their own, and weapons are their own. So basically, poodle is a dog, but poodle is not a bird, but they are all animals. Dog will never be an interactable or a character or a pickup or a hazard. Same thing, Ford is not an animal. Ford is not a character. And uh weapon sniper is not a trace weapon but it&#39;s still a weapon but it will never be an animal or a character as you can see right here. Now what does that mean is a relationship in the Unreal Engine. So to properly design a class hierarchy using inheritance we have to follow the is a relationship. Is a relationship is a type of relationship where child class is a specialized version of the parent class. Usually when we are just pro programming, we would only need to think about methods and variables when the designing a class hierarchy. But in the Unreal Engine, if we are working with a class that can be instanced into the level, meaning we can see it in the game, then we know that that class inherits from the built-in actor class. If we are working with an actor class or child classes of an actor class like bonds, character and so on, then we will need to think about components as well. We can see in this diagram right here. BP pickup base has two components. A static mesh component for rendering visual representation and sphere collision component for detecting collision. All of these pickups use or child classes of VBA inherit and use those components. One step for creating a pickup is defining the in the inherited static mesh where we define the 3D model for a specific pickup. BB pickup coin needs to have a 3D model of a cone. BB pickup cupcake needs to have a 3D model of a cupcake. Now BB playable character base has a lot of components. Capsule component for collision. Arrow component for direction. Skeletal mesh component for rendering whiz presentation. Camera boom and followup camera for rendering the image and character movement component for movement. BP, Manny, and BB Queen inherit all of these components. And the only step for creating a new uh character character class is just defining the skeletal mesh component because the skeletal mesh uh all of the vis all of these are abstract classes and they shouldn&#39;t have anything defined that can uh load something heavy into the memory which is usually a visual representation 3D models materials and uh textures that hold those materials hold is a relationship is a type of relationship where child classes is a specialized version of the parent class. In this example, the specialization between these child classes is actually defining the value from one of the inherited components. And that&#39;s what we need to think about uh spec specifically on the Unreal Engine not that uh not only that base class pen class needs to share the methods and variables, it also needs to share components. We always need to think about components. Now let&#39;s see uh steps how we can create a class hierarchy in Unreal Engine uh with the inheritance using the ESA relationship. First uh we need to determine the main theme functionality of the hierarchy. For example, is it pickups, hazards, interactables, animals, weapons, cars, characters, so on and so on. Now we will use our pickups as an example. We already did them but let&#39;s now see how it was made in uh identify common features for this functionality. Use bullet points describe it. Okay. And then we can create a parent class for the functionality. BP name of the functionality. Okay. Pickups base. It can hold components, variables and methods, events and functions. And that should be always an abstract class. Write down variables, methods and components that child classes will need. Okay. So let&#39;s see. All pickups have a spinning and floating animation. So let&#39;s in the method uh on the begin play have that rotating and floating animation. Now uh all of them get destroyed at the pickup. They all affect players health gold and score variables and all pickups should give score. So on collision we cast to the B level character base because it affects health gold score variable. We call up the pickup manager. That&#39;s the event that affects those variables and uh it gets destroyed after the pickup. Now all the pickups should give score is for the child class. Now here I have actually explained how my pickups work. They&#39;re basically loosely based on the JJ Jack rabbits uh thing, but health they all have the same static mesh of cross but different colors depending on how much health they give. Gold they all have visual representation of gold or treasure like coin, coin pouch, goblet, crowns, money stacks and so on. and score. They all have vis visual representation of food like cupcakes, burgers and fast food, fruits, vegetable, dishes and so on. So now come up with potential child classes and write it down which specific uh components will each child class need and which specific functionalities will each child class need? What does it do? What does it affect? So let&#39;s say we have like a BP coin. It has a static mesh and sphere collision and methods on collision. Basically on this on component overlap gives one gold and 20 score to the player. It has a static mesh and sphere collision and on collision gives 50 health and 10 score to the player. Cupcake gives it has a static mesh for lo representation. A sphere collision for detected collision and on collision gives 100 score to the player. Uh burger has a static mesh for representation. Sphere collision for detected collision and collision gives 500 score to the player. and a BP coin pouch. It has a static mesh for representation. Sphere collision for detecting collision and on collision gives 10 gold and 100 score to the player. So compare the list of your potential child classes. Do they all share the same thing and put it in the same parent class and of course be extra careful to see if they share components. Now let&#39;s look at a bit about components. So always start with components on step number four. That&#39;s where we are now. Let&#39;s think about all of these uh shared classes that could be in the same uh class hierarchy. Let&#39;s look at the components for rendering whistle representation. Are they static mesh, skeletal mesh, particle systems, spline mesh, postprocess and so on. And components for detect collision. Are they box collision, capsule collisions, sphere collision? Components for movement, animation could be rotating movement, interpretive movement, projectile movement, character movement, floating pal movement and many other components like lights, audio, AI and so on. Now thankfully as you can see in all our pickups they all use the static mesh uh for component for the rendering the visual representation. So we can put that in BPP cabase because they all share the same component for rendering the visual representation and as you would see they all share the sphere collision component for detecting collision. This is how we can create a class hierarchy. we uh create uh an examples of all of our potential candidates that could be child classes of the base class and see what they share or more importantly what they don&#39;t share. Now in this case this is a good example because they are specialized classes in that way they all share the static mesh component for representation sphere collision for that collision they all share the same code and so on. So that&#39;s it. That&#39;s how we can create a uh class hierarchy where parent child class needs to be a specialized version of the parent class. Now we will go to our next topic which will be polymorphism. So let&#39;s look at the definitions. Uh polymorphism is the ability of one function or method to perform different actions depending on the input or the type of object it&#39;s called upon. Polymorphism allows us to perform a single action in different ways. Polymorphism allows you to define one interface and have multiple implementations. Now, let&#39;s take this definitions and make one for Unreal Engine. So, polymorphism is the ability of an event to perform different actions depending on the type of actor it&#39;s call upon. There are actually multiple polymorphism in programming, but we will just focus on events and functions. For this one we have actually encount encountered this polymorphism. This is that polymorphic event common functionality with different implementation where event is created in one class but code for that event is implemented in multiple different classes. It&#39;s called overriding in inheritance. So when should we have actually encountered this uh when we created our pickups we created uh the event on pickup in the parent class but actually implemented that event in the child classes but we actually succeeded to have all of the code in the parent class only. That&#39;s because a polymorphic event should only be used when functionality does different things between classes and or and or functionality affects different things between classes. In our case with our pickups, functionality affected the same things, the same three variables from the characters class. And actually the functionality does the same thing. Um, no matter there are different variables, they are uh the code is the new value is the current value plus some input. So we should only use a polymorphic event when functionality does different things between child classes. In this case, if we talk about inheritance or functionality affects different things between child classes. In our case, we didn&#39;t encounter that example yet. Which will we do now? Now, nolmorphism is the ability of an event to perform different actions depending on type of actor it&#39;s called upon. Okay. So, uh one way we could actually showcase polymorphism is by creating an interaction system. We have BP interact base where we create a custom event on interact and then we have BP door which overrides that custom event for opening and closing door or lamp for turning on and off the lamp. So let&#39;s see an example how we can create a class hierarchy in Arnold engine following these steps. So determine main team domain functionality of the hierarchy. We will have interactables. Identify common features for this functionality when player presses an F key. So this is implemented in the player BB playable character base. It shoots up a line choice and uh interacts with the actor if the actor is interactable. Okay, we have described it for now. create a parent class for the functionality BP interactable base. It can hold components, variables, methods and so on. For now, I know that it will hold one event and that will be BP interact base which will hold on interact. And now I know how we can check if the actor is interactable. We can check check by casting to the BP interact base and call the on interact event. Now we need to come up with potential child classes and write them down down which specific components will each child class need and which specific functionalities will each class need. So let&#39;s do just that. Now this will be we will do in pen and paper but now we have presentation. So we have methods on interact and first chat class will be BP door which has components such as static mesh door and static mesh door frame and method is overriding the on interact event by opening and closing the door. Next one is BP lamp which has a static mesh lamp ceiling and point light component and method is overriding the on interactive end by turning on and off the lamp or light in this case. The third one is BP weapon which has skeletal mesh weapon component and arrow component and method is overriding or interact which equips a weapon in hand. And lastly it&#39;s BP fire which has components such as Niagara fire that&#39;s a particle system component a point light component and box collision component and method is overriding on interact where we can light or put out the fire. So we have now come up with our examples. Next what we need to do is compare the list of our potential child classes. Do they all share the same thing? Maybe we can put it in the brand class. But let&#39;s first check our components. Do they share any of the components? Now they all have some kind of a component for rendering visual representation. BP door has two static mesh components. BP lamp has a static mesh lamp ceiling component. BP weapon has a skeletal mesh component and BP fire this Nagara fire that&#39;s actually a particle system component. So they all use a component for rendering a visual presentation but they are different components. Uh now BP fire uses a component for detecting collision such as a box collision and uh that&#39;s basically it. So there are no shared components for visual representation. So we cannot put anything in the BP interact base because different child classes need a different kind of component to render the visual impation and other components are only specific for each class. For example, point light component is for the lamp so we can turn on and off the light. Arrow component is for the muzzle so we can have direction and spawn line trace or something else. Point light is for the ambient light of the fire and box collision is if the player steps on the fire so he can get hurt. So basically there are no shared components between these four interactables and uh is a relationship that says the child class is a specialist version of the parent class and there are no specialization in such a way that they can inherit any of the components. So let now uh we need to think about the last thing. Do they all share functionality? What does it do? What does it affect? Is it a common functionality with same implementation or is it common functionality with different implementations? Is it a polymorphic event? Each child class has its own implementation. That&#39;s what that polymorphic event means. Let&#39;s look at it now. Event should only be polymorphic if functionality does a different thing between child classes or functionality affects different things between child classes. So let&#39;s look at BP door. What does it affect? It affects the static mesh door component. Uh, opening and closing the door is affecting the static mesh door component and it rotates it by 90. For the light, it affects the point light component. Okay, between them, we are affecting different things and we are doing different things. We are setting the light intensity of the point light component. BP weapon, it affects the player and itself. It attaches to the player&#39;s hand and activates the event listeners. basically listening if the player presses the shoot key, the reload key, yada yada yada. And lastly, uh BB fire, it affects all of the components. What does it do? Activates or deactivates component. Ah, if we light the fire, we will activate the visual representation of fire. We will activate the ambient light and player will get hurt if he steps on the fire. But if we put out the fire, there is no fire effect. There is no light from the fire and we can&#39;t get hurt by if we don&#39;t have fire. So that&#39;s basic list. Now let&#39;s create our own interaction system that will have BP door, BP lamp and BP TV. So let&#39;s now create our interaction system with inheritance. First I will create a new folder. In here we have to uh create a parent class which is a BP interact base. This will be an actor and we will call it BP interact interact base. Now this uh is a parent class but it should also be an abstract class. So let&#39;s generate one as such. So now this is a abstract class. Let&#39;s compile and save. And now let&#39;s see what we need to do. We will not add any of the components because each child class it&#39;s its own interactable thing. they might they might need different components between each other and there between let&#39;s say 30 interactables there won&#39;t be any of the components that they all would share. So let&#39;s now uh we can see that we don&#39;t add any of the variables as well. We just need to add a method on interact. So let&#39;s create a custom event called on interact. Compile and save. Now we need to create child classes which we can actually put in the level and interact with. We have BP door, BP lamp and the BP TV. I will create all of these three child classes and in uh add the components to them. So let&#39;s do that. [Music] Now we have done uh created all of these three child classes which are a uh have parent class for BP interact base as we can see right here and uh we have added all of the components. So BP interact doors needs to have two static meshes. BP interact lamp needs to have a static mesh and point component which is under the static mesh component. So if we move the static mesh component, the point light will follow its position and be interactiv. Now what we need to do is uh override the on interact event to actually define what does that interaction do for each of those child classes. For BP door, it&#39;s opening and closing the door. For BP lamp, it&#39;s turning on and off the light. And for BP TV, it&#39;s turning on and off the TV. So let&#39;s now do just that. Okay. So let&#39;s see what we have done. Now in the beep interact base we have an event on interact child classes inherit that event and implement what that on interact actually does. For BP door we are opening and closing the door. For BP interact lamp we are turning on and off the light and for BP interact TV we are turning on and off the TV. So but what are we really doing? We are now doing common functionality with different implementations. We are creating a polymorphic event. Event is created in one class. This is in the parent class and code for that event is implemented in multiple different classes. In this case that would be child classes in beep interact door beep interact lamp and beep interact TV. Now one thing to look out for uh look how in the parent class B beep interact base how we named this event on interact. That&#39;s it. But child classes the the the classes that we actually take that you know override that event is actually called event on interact event on interact event on interact. That&#39;s how you can know that you are actually implementing an event that was not created in that class. It&#39;s actually it&#39;s from some another class. Now let&#39;s see what we have done. Uh so uh we can we should only use a common functionality with different implementations aka we should only use a polymorphic event when functionality does different things between child classes or functionality affects different things between child classes. So let&#39;s look at for BP interact door in here we are affecting static mesh door component by rotating it by 90 with the help of our timeline. Okay, affecting the static mesh component and rotating that static mesh component in the BP drag door. In the lamp, we are affecting the point light component and uh by uh by setting the light intensity between 10,000 and zero. So, we are affecting different components between the door and lamp. This is a static mesh component. This is a pointlet component. And for BP uh TV, we are affecting the static mesh component. We are affecting the same compon basically the same type of component as in the door but in here we are setting new material basically from the material white emission turning on the TV to turning off the TV. Now we have this on interact event and we uh each shell class actually defines what that interaction on interact event does what that interaction does but we need to call it from somewhere we need to because this is an interactable player should actually press the key. So let&#39;s see how we can do that. So we have all of the align trace from before. When the player presses an F key, we can get a hit actor reference. Instead of now casting to the BP cube, we can cast to the BP interact base. Now remember, we should only cast to the uh parent abstract classes and from there we can just call up the on interact event. Uh and now when we interact with the instance child class of BP interact base we will get the reference we will call the on interact event but uh depending on which child class we are actually getting the reference from they will actually implement the overridden event on interact. It won&#39;t take the parents uh event. It will take the specific implementation for that class. And this is also closely following the rule. The code that manipulates a specific class should be in the class that that class code that manipulates the static mesh door is in the BP door. The code that manipulates the point component is in the point component and so on. But in this case we have to have the uh polymorphic event because functionality does different things between chart classes and functionality affects different things between shot classes. So here we have in here cast to the beep interact base on interact. Let&#39;s put this now three interactables into the level and test this. Oh, and BP TV. And let&#39;s now see if this works. First with the door and they open and close. With the TV, it can turn on and off. And with the lamp, we can turn on and off the light. As we can see now we have our interaction system through inheritance and let&#39;s actually also actually add a warning if we are trying to interact with something that is not interactable. So we will say cast failed hit actor is not a child class of bp interact base. So basically it warned us that we are trying to interact with something that is not in the family of interactables as we can see right here. But if we try to interact with child classes with interact base everything still works. We have created pickups with inheritance and we have created interactable objects with inheritance. Let&#39;s now try and create hazards uh with inheritance. So now we can have something uh that can be challenging for the player. So when we want to create a class hierarchy uh using inheritance following the is a relationship we need to follow some kind of steps. First we need to determine the main theme functionality. In this case that would be hazards. Next we need to describe what that functionality is. In this case if we can explain it such as if pickups are good for the player hazards are bad for the player. That&#39;s what makes the game challenging. The only reason for their existence is to harm the player. This usually means subtracting health from the player, but also there can be exceptions that are not targeting health but use other form of punishment. For an example, ice type hazard could freeze the player, something like from the Sonic the Hedgehog. But generally in this example, their main functionality is subtracting health from the player. Uh now we need to uh create a parent class for the functionality BP hazard base. Uh write down variables and methods and components that all child classes will need. Right now I actually cannot predict what kind of components and methods and variables all child classes will share. I can kind of predict that there will be methods for substructing health. Uh to solve that problem we can come up with potential child classes and write them down. Which specific components will each child class need and which specific functionalities will will each child class need. And right here these are examples that we can uh see in here we have ice and bomb. They both use static mesh component for wizzler representation but they use different kind of components for detecting collision. They both have rotating uh need a rotating and floating animation. They basically imitate pickups but they don&#39;t give healthy golden score on collision. Ice freezes the player while bomb substructs health from the player. Uh now in fire it has a particle system for visual representation but we in spikes we have some kind of animation that goes spikes uh for the spikes up and down. Cannonball uses sphere collision and projectile movement. Piranha plant has a skeletal mesh component for it stationation. There are a lot of things in here that we need to compare which is actually our next step. Compare the list of your potential child classes. But first we will compare the components and then anything else. So BP hazard base is actually created from the built-in parent actor class and from there we have created a child class of ice which has a static mesh component and box collision component. bomb which has a static mesh and sphere collision. Ice fire which has a particle system and box collision. Cannonball which has a static mesh, sphere collision and projectile movement. Laser which has two static meshes and a box collision. Spikes also has two static meshes and a box collision. And piranha plant which has a skeletal mesh component and sphere collision component. Now com uh there are different components for rendering with representation between these child classes. uh most of them use static mesh component but fire uses a particle system and piranha skeletal mesh component. Now if you want to create a proper proper class hierarchy we need to follow the is a relationship. Child class is a specialized version of the parent class. These are only uh seven examples and two are already outliers in here. So what would actually happen in theoretical example if I put the static mesh in the BP hazard B base? Ice and bomb would inherit the static mesh and use it. Uh cannonball will inherit and use it. Laser and spikes will inherit use it. But we will also need to add another static mesh for both of these actors. But the biggest problem would be with the fire and firana. Fire would inherit the static mesh component from the parent class. but cannot but the fire cannot delete the the inherited component. Cannot use it for uh visual representation because it&#39;s not a static mesh. It&#39;s a particle effect and then we will need to hide this component and still add the particle system. So we can actually render the particle effect. Same thing with piranha plant. We cannot delete the inherited static mesh component. We cannot use it because it has a skeletal mesh component in the 3D model. So we have to hide it and we will still need to add a skeletal mesh component. So for uh for this we will not have any kind of uh shared uh components for rendering visor station. What would happen if we put a box collision component in the parent classes? Well, ice, fire, laser, spikes will just inherit it and use it. But the problem is with the bomb, cannonball and piranha, they all cannot delete it. They can all cannot use it because it doesn&#39;t uh surround the 3D model the best way. So all of them will need to hide that component and they will still need to add a sphere collision component. So no go with components. We they don&#39;t share any kind of components both for rendering visual representation or for detecting collision. So it would be best to not have any kind of components. And lastly components for movement. Cannonball actually has a projectile movement in it. But that&#39;s specific for it. None of the other classes actually need it. So now we need to compare all of our now all of our child classes. Do they all share the same thing? Put it in the parent class. Now it would be best they actually share all of the same things like in the pickups. But let&#39;s see uh what we can do with the shared functionalities that they actually described with our potential child classes. So first what we have is uh potential hazards uh substract health. That&#39;s their main functionality. That&#39;s that&#39;s their point of existence. They should subtract health really. Bomb uh spikes, piranha plant, laser, and cannonball all have the same functionality on collision. They want to subtract health from the player. So the first uh shared functionality or method is on damage that we will actually put in BP hazard base. On damage changes the current value of a health variable. Now we will uh now this is only uh this is a common functionality with same implementation. It&#39;s implemented in the BP hazard base, but it&#39;s not actually called. We will call on damage only on the uh actors that will actually need it. That is the B bomb, cannonball, laser, spikes, and piranha plant. Next, uh fire is while colliding subtract health from the player. So basically, while the player is stepping on the fire, it should subtract health. There&#39;s a condition. Now in here we have only one example of uh this kind of functionality but there are many others if we would actually create a game that would use this kind of functionality. For an example drawing, drowning, freezing, bleeding, radiation, toxic cloud and so on so so on and so on. They would al have some kind of damage on condition. So damage on condition is actually when uh handles gradual changes in health based on condition. Is the player stepping on the fire? If it is then uh gradually change the health to minus no. Uh then we have rotating and floating animations. We will also implement uh create the event uh create them and implement them in the BP hazard base. But we will not call them in the base class because all of them then will inherit the spinning and rotating in floating animation. So we should only uh call them on the classes that need them. ice. Uh we will call this on begin play on ice and bomb and only the rotating animation on the laser. We have now in this green uh squares uh we have uh basically uh set all of the things that now we have implemented in the parent classes. Other things are specific for that child class itself. So on collision with ice freeze the player and destroy the actor. Destroying the actor on these three classes as well. Uh cannonball has a lifespan. We have some kind of animation in piranha plant and we have some kind of animation of spikes going up and down in the spikes. So we can do just write that down in here. So an ice freeze the player. This doesn&#39;t this is not an event. This is just an description what it should do and then destroy the actor. We should destroy the actor on the bomb. We should destroy the actor and cannonball and on begin play animation for spikes. Uh we should have some kind of specific animation for the spikes actor itself. And lastly, we will actually not have a piranha plant as an example. So this is the class hierarchy that we will now try and recreate in the Unreal Engine. Okay. So first we will create a new folder. This will be hazards inheritance. in here in uh we will create our BP hazard base from the actor class and we will call it BP hazard base. Let&#39;s open it up and uh first what we will what we will do is generate it as an abstract class. So we don&#39;t want to instance this into the level. Now we already know that we won&#39;t have any components. Now first I will create the child classes and put their components in and then we will worry about the code. So uh let&#39;s do just that. Right now I will create a cannon that will shoot uh her hazard cannonballs. [Music] So now we have uh put all of the components in child classes. Now we can focus on methods. Uh we will have four methods in the BP hazard base. The abstract parent class that uh some of the child classes will inherit. First method is on damage. Uh on damage changes the current value of health variable. In this case that would be players health variable. So let&#39;s do just that. In the BP hazard base we will uh create a new custom event called on damage. And on damage what does? Oh it subtracts health from the player. So what we need to do is we need to cast to the BP playable character base. Now remember we are always casting to the abstract classes. So it can both affect BP Manny and BP queen. Now we need to pass the reference from the other actor. Now when we will call this on damage event we will call it when when we are colliding with the bomb uh with the uh laser with the spikes with the cannonball. So we call this on damage event when we collide with our child classes. So for an example in BP hazard bomb we can go to the sphere collision component and on component begin overlap we will get this other other act uh other actor reference where we usually call this cast to BP playable character base and so on. But for now we will call this on damage event but we will still need to have to have this input of another actor. So that&#39;s what we will do in our BP hazard base. We will for the uh on damage input have the other actor uh input which will just have an actor object reference. We can pass through any uh actor from the game. In this case that will be casted level character base. Now one thing that we need to remember uh the code that manipulates a specific class should be in that class. We want to manipulate the player&#39;s health variable. So let&#39;s create an event or a function. Uh in this case, this will be an event that will actually allow us to uh manipulate the health variable. Now it&#39;s actually really simple. We will create a new custom event called add health because we will have the simple code of addition of health. So new health value is a current one plus some input. Of course on damage that could be actually be minus uh negative value. This will be input of health value. Compile and save. And in the BP hazard base, we will call this event right here. And a health value will be as an input. So for an example in BP harm actor bump I can now uh from this uh on component begin overlap call the on damage uh event that is inherited from the BP hazard base class. So on damage we will get this other actor reference will be other actor reference and health value will be minus 20 and after that we need to uh destroy the actor. Let&#39;s quickly test this if this works. In be level character base, I will add that health value is 100 as a default. And if I now put this into the level and try to collide with it. As you can see, now I have 80 health. I lost 20. But let&#39;s now focus on the second part which is a damage on condition. Damage on condition handles gradual changes in health based on condition. So while something is true like we are stepping on fire we are we have the plating health. So let&#39;s do that right here. This is a simple code which basically checks if the condition is true and if it&#39;s true call the on damage event and after some delay which is this event right here which basically cast to and calls the add health event and uh after the delay we call this event again and if the condition is still true we call it again again and again. We can actually implement that in the BP hazard fire which calls up this damage on condition event. So let&#39;s do just that right now. First we will have on component begin overlap and over end and end end overlap. So we can have both the condition for true and condition for false. And let&#39;s quickly test if this now works if we put BP hazard fire into the level. So we have 100 health and now we are losing health. But when we step out of the fire we stop losing health. We are we are now stepping on the fire and losing health and now stopped losing health. So that&#39;s basically how this works. Oba now we need to uh work on this floating rotating animation and floating animation. Uh we can actually steal this code from the pickups uh right here. But the only problem is that we actually have uh one timeline that both runs rotating and floating animation. So we will need to reactor this code to have two timelines. One just for rotation and one just for flotation. So that ice and bomb can use both of these animations but laser can just use the rotating animation. So let&#39;s do just that. [Music] And now we can actually uh and now we can actually implement all of these things in uh all of these events on the child classes that will need these things. So first we will have freeze player which has its own code of freezing the character. Uh let&#39;s say for two seconds. So let&#39;s first focus on the ice. So, Let&#39;s see what we have done in BP hazard base. We have four events on damage, damage on condition, rotating and floating animation. Now both of the all of these events are uh common functionality with same implementation. We have created the events and also in the in the parent class but also have the code for this events in the same parent class. Child classes will now just call those events. Uh the only difference is in the ice where we actually have the code for specific for ice so it can freeze the player. In the BP hazard ice on component begin overlap we cast to the character so we can access the character movement component so we can set the movement mode. The movement mode is set to none and after 2 seconds we revert it back back to walking from where we destroy the actor. Now because we have a delay before destroying the actor, we hide the static mesh so it looks like the player picked it up uh by just setting the relative scale 3D to zero. And also we on begin play call up the rotating animation and floating animation which is implemented in the parent class. BP hazard bump has uh on collision on component begin overlap where we call the on damage event and then destroy the actor and on begin play we call up the rotating and floating animations for BP hazard fire we call uh call the damage on condition event when on component begin overlap the condition is true and for every 2 seconds we subtract one health from the player&#39;s health and on end overlap condition is false and everything is reversed convert it back to default values. In the BP hazard cannonball, we have on collision begin overlap. We call up the on damage event and then destroy the actor. We also have set lifespan for 5 seconds which means after the actor is spawned after 5 seconds it will get destroyed. Uh for BB hazard laser we have uh on collision we on component begin overlap we call up the on damage event and on begin play we call the rotating animation. And lastly for hazard spikes we also have on collision we call up the on damage event. And for the animation uh we have now custom animation that makes the spikes go up and down uh with the help of our timeline right here. So as you can see we have make created events in our parent class and we are just calling them and uh specifying what uh inputting inputs on what each event does. Only the rentings right here are actually specializations that are not taken or called from the parent class but for themselves. Ice is the only one that doesn&#39;t actually harm the player by subtracting health by by freezing the player. All of these three actors destroy themselves after the collision. Cannonball has a lifespan which is only a specialization for the cannonball and spikes have their own specific animations of spikes going up and down unlike the rotating and floating animations which laser ice and bomb utilize. So let&#39;s now put these hazards into the level and test them. So let&#39;s now test this first. Uh we have our BP hazard ice which should actually have when we collide with it, it should freeze the player for two seconds and after that it should destroy itself. It should also have a rotating and floating animation. Uh there is actually no floating animation for these two. Oh uh I guess we need to connect this. Well, it&#39;s always so here&#39;s just a proof. It&#39;s always best to have the diagram with you so we can actually check which kind of functionalities we have or don&#39;t. Okay, so let&#39;s now test if this works. So ice needs to ice and bomb both need to actually have a rotating and floating animation. They do. With the ice, it should freeze the player&#39;s moment for 2 seconds. And with the bomb on collision, it should actually call up the on damage and it should take 20 damage. As we can see here for the fire, we have the just damage on condition. So when we collide with the fire, we are losing health. We have depleting health. We step out of the fire, we stop losing health. It&#39;s pretty simple. Now for the spikes, they have their own animation for spikes. And when we collide with them, we should lose 10 as well. So now when I step on uh the spikes, when they are not up, I am not losing health. But when they are up, I should lose 10 health. Same with thing with the laser. On collision, I should lose 10 health. And the laser also has just the rotating animation as we can see right here. And from the cannonball, I should lose 50. Now, right now, I have minus 10 health, which is which for now I should be that. But as we can see, all of the functionalities work that were defined in here. And we don&#39;t have the bomb and ice anymore because they get destroyed on the when we collide with them. Same thing with our uh cannonballs. But this minus 60, we should maybe do something about that a little bit later. So we have found out that we can actually get the our player&#39;s health below zero and player can still play the game. So let&#39;s see what we can do about that. We can we can always ask ourselves what does the code do? But we also should ask ourselves what does the code affect. In here we have our functionalities basic functionalities of subtracting health. In the BB level character base we have an anat health event which has a simple nodes of just uh uh simple addition for manipulating the health variable. In the BP hazard base class we have on damage event which cast to the BP level character base. It&#39;s an abstract class and casting is just telling the Unreal Engine hey I need this BP level character base class so I can access the odd health event. It&#39;s a specific event for our player. And this event, as we said, just manipulates the health variable. And then we have child classes of BP hazard base uh classes that can that can actually be instant into the level. And they just have a simple uh call for the event on damage where we can define that other actor is uh for the cast of the BB level character base and just input how much each of these hazards actually takes health from the player. BB Hazard bomb stacks minus 20 while cannonball minus 50 and so on and so on. So we have now a task if player&#39;s health gets to zero or less destroy the player. So uh we can always ask ourselves what does the code do. So what does the code do? The it destroys the player when his health gets to zero. Okay, we have a description, but where would we want to implement this to have the best results where we don&#39;t need to change the code in a lot of the classes. So, uh we can you can pause this video for a second and choose. But for now, let&#39;s go on. We can we can ask ourselves what does the code do, but we should also ask ourselves what does the code affect? In this case, it affects players variable, which means it affects the variable created in the BP level character base. We are manipulating the health variable with our at health event. So, we should always follow the rule, the code that manipulates the specific class should be in that class. In this case, the code for destroying the player when and if his health gets to zero should be implemented in the playable character base and preferably with our odd health. This this is where we actually manipulate the health variable. So we can just then add a check if it&#39;s below zero and if it is it destroys the actor and we are destroying our player in the BP level character base. The code that manipulates the specific class even the destroying should be in that class should be in the BB level character base. Let&#39;s compare what would happen if we use duplicated classes with duplicated code for our hazards or using the inheritance code reuse especially sharing the on damage event. In here we are basically just have the on damage event and BP uh and child classes that can be instances the level just call this event and define how much health it should take for from the player for each of these child classes. But if we duplicated code we would have basically this. Now uh I explained the most basically what could inheritance be is basically taking the all of the duplicated code between classes and put it in into the parent class. So let&#39;s break down this more uh closely. We have cast into the BB level character base and our own damage event would take that. Then we have manipulating of health variable. But in here we are calling the odd health event which actually uh has that same code in the BP level character base. That&#39;s because the code that manipulates the specific class should be in that class. So basically we took all of this duplicated code and put uh put it in the parent class and call this duplicated code on damage event. And then instead of on all of these classes doing all of that, we can just call that on damage event on all of the child classes. And as you can see implementation is simple as that. And uh we have the same thing in our diagram. We on collision we are just calling already builtin classes. Destroy actor destroy actor is actual built-in uh function in the unreal engine. But uh on damage on damage on condition on damage on damage on damage are built-in classes that we have built it in our parent class BP castle base. child classes inherit those events and they can just call and define how much damage should each this child class take how much damage should each this uh hazard uh take from the player. But now if what happens if we actually get a task uh if player&#39;s health goes below zero uh then destroy the player. If we have this uh class hierarchy we can just do that and that&#39;s it. We don&#39;t need to change any of the code in the BB hazard base or all of its shout classes. But if we get that same task between these duplicated classes, we would need to go to each duplicated class and implement that code. And that&#39;s basically the power of inheritance is just basically having each specialized class for each specialized things. Child class is a specialized version of the parent class. And uh basically if uh if uh a uh one uh one one family or one class hierarchy needs to communicate with another class hierarchy we use casting where uh BP hazard base an abstract class cast to another abstract class which is a BB playable character base and that&#39;s how we should share functionalities with inheritance. So let&#39;s now test if this works. As we can see in the B level character base, we have this check. If the health gets below zero, we destroy the actor. So, let&#39;s test if this now works with the bomb, we lose 20. Fire has a depleting health. And I have added logs uh as a static mesh so we can see where the fire is coming from. And we just need to get this health below zero. So, 15 five. And we got destroyed. And so, our character will get destroyed when the health gets below zero. So now we have done our hazards uh in the level with the help of the inheritance. Let&#39;s create a new functionality. I want to create a non-playable character, an NPC that we can actually interact with and he can give us quests. So if we want to interact with NPC, we have to go through our interaction system. Now to create a new interactable, it&#39;s really simple. We just go to our parent BP interact base, our abstract parent class, and just click create a child blueprint class. And that&#39;s it. We will name this BP interact NPC. Let&#39;s open it up. Now I don&#39;t see uh skeletal mesh and the character movement component, caps component, so on. So I will add them myself. I have added a skeletal mesh and I will add a character movement component. Oh, as you can see, I cannot add a character movement component. So why is that? BP interact NPC is a child class of BP interact base which is a child class of a built-in actor class. So right now as we can see we were never even asked if we want a character class. It just when we right click create a child born class it just creates for us. Uh but when I want to create a new class like right click bloopin class I can actually choose to pick a built-in parent class. Is it actor pawn or character? Right now, beep interact NPC basically inherits from the beep interact base which inherits from the built-in actor class. We are never inheriting from pawn or character. So, let&#39;s be sneaky. I will try and just create a new character class and call this BP interact character. And now, as you can see, I have this uh capsule component, arrow component, skeletal mesh component, character movement component. Now this will be skele skeletal mesh manny simple let&#39;s add him to the level something like this and something like this now of course if I go to event graph I will try now to call this on interact event but I don&#39;t see anything I don&#39;t see anything because uh for uh interactables to inherit the on interact event it needs to inherit from the parent class BP interact base which actually holds that event BP interact character inherits from the built-in parent class. So what I&#39;ll try to do in the class settings, I can just go and change the parent class to BP interact base. Reparenting this blueprint may cause that loss. Continue reparenting. Okay, let&#39;s try and reparent. The data loss that just happened is that we lost the components. We don&#39;t have a character. Now we can actually if we compile get the event on interact because now we have a beep interact base as a parent class and we can inherit the interact event on direct but we don&#39;t have a character anymore. So basically we cannot do anything right now. So let&#39;s see what we can do about that. So why cannot we add non-level characters to bin base. If we try to create a child class from BP interact base that CH class would inherit from the built-in parent class, but it doesn&#39;t inherit from the built-in pawn class where we get a controller or built-in character class where we get character movement component. So basically we need to have two two different built-in parent classes for our functionalities to work. uh the built-in class for BP direct base is an actor for but the built-in parent class for BPNC should be a car built-in character class. So uh the first basically we would need to create two uh unrelated classes or this case class hierarchy and unrelated class hierarchy of NPCs and we need to create from the built-in character class because uh we uh we need to inherit from the character class for our NPC to work properly. and RBP interact base cannot provide that. So what now? How can we share uh common functionalities or in this case polymorphic event on interact between two unrelated class hierarchies? The simple answer is we can&#39;t inheritance cannot share common functionalities between unrelated classes. Only thing we can do right now is just uh create uh an event on interact NPC and this is a separate event. This is not a polymorphic event. We just created two custom events and then in the uh BP level character base we can from the cast field cast to the BP NPC and then call this on interact NPC. And as you can see if the cast fails cast failed hit actor does not have a version of on interact events. Basically we would need to have multiple uh different uh versions of on interact events for as how many class hierarchies we would need to have that interaction system. Okay. So what would happen if we try to add NPC to BP hazard base or hazard classes? The same thing happens. BP hazard base inherits from the built-in actor class and BPNC base needs to inherit from the built-in character class. And in this case, inheritance cannot share common functionalities between unrelated classes. In this case, this would be this common functionality and say implementation aka monomorphic event. The only thing we can do is basically create another on damage NPC event and duplicate code. We need to duplicate to code because we cannot work with inheritance. Let&#39;s try something else. Instead, let&#39;s try and share a common functionality between two unrelated classes, but they both have an actor as a built-in parent class. And for this example, I want to try and interact with the fire. Right now, fire is in the hazard class hierarchy. It has BP hazard base as a parent class. And if I want to interact with the fire as well, I need to put it as a child class of BP interact base. So we can inherit the on interact event and override it to have something like ignite and extinguish fire. So let&#39;s see what happens if I uh put fire as a as a child class of BP interact base. Well, now fire right now fire inherits from the BP interact base which shares the functionality of on of interaction. But because we stop inheriting from the BP hazard base, fire cannot inherit and call the uh damage on condition event. There is a compilation error. So uh we can we have to delete these two nodes and this is the end result. We can collide with the fire but we are not losing health. We are not inheriting from BP hazard base but we can interact with it. We can extinguish and ignite the fire. Inheritance follows the is a relationship. Right now, fire is inheriting from the BP interact base, which means fire is an interactable actor, not a hazard actor. Okay, let&#39;s try and avert it back. Uh, so it can hurt us again when we collide with the box collision. So, right now, fire inherits from the BP hazard base uh which shares the functionality of damaging the players by subtracting health from the player. This event has damage on condition event. But because we stopped inheriting from the BP interact base, we cannot inherit an override on interact event. Now we we are losing health if we if we collide with fire, but we cannot interact with it. So what what that means? Uh inheritance follows the is a relationship. Right now fire is inheriting from BP hazard base which means fire is a hazard actor not an interactable actor. And that&#39;s the thing with inheritance. Inheritance need to follow the is a relationship. Is a relationship represents type of relationship where child class is a specialized version of the parent class. Fire can only have one direct parent class. With that parent class, we are determining the specialization for our fire actor. So fire is an interactable actor. Fire is a hazard actor. Fire is an interactable actor. Fire is a hazard actor. Unfortunately, BP hazard base and BP interact base are two unrelated classes with two unrelated class hierarchies. And unfortunately, inheritance cannot share functionalities between unrelated classes. So if I want to interact with BP hazard fire, so people would do something like this. But remember never cast to child classes that can actually load a visual representation into the memory. We need to create our own interact hazard event in the BP hazard base. And then fire can inherit and override what that interaction does. But because inheritance cannot share common functionalities in this case would be polymorphic on interact event. We are creating basically separate on interact events. What if want to interact with weapons then cast failed cast to BP weapon base then cast failed cast to BP vehicle base and so on and so on. We could have 100 different casts uh to cover all of the things that player could interact with. So inheritance cannot share common functionalities with unrelated classes whether it be common functionality with same implementation or different implementation whether it be monomorphic or polorphic events. Now in here we have this general description on how to share this common functionalities. Let&#39;s turn that into a table. In here we have a description or general description. In here we have a description how to implement this things with inheritance. And now we will talk about how we can implement monomorphic or polymorphic events between unrelated losses. First let&#39;s focus on common functionality at implementation aka how to share a monomorphic event between unrelated losses uh using custom looping components and following composition principles. The composition is something that could be also called composition over inheritance. So composition over the inheritance or composite reuse principle in object-oriented programming is the principle that classes should favor polymorphic behavior and code reuse by their composition by containing uh instances of other classes that implement the desired functionality over inheritance from a base or a parent class. So let&#39;s break this down. Inheritance. This feature promotes code visibility. Okay, promotes code visibility and composition. Code reused by their composition. So promotes code reability. With inheritance we also have creates a parent child relationship between classes. It has some kind of relationship. Now in here it doesn&#39;t say the keyword relationship but this underlying thing by containing instances of other classes that implement the design functionality. It also has some kind of relationship with inheritance. We also know that as a parent parent class child class relationship uh where child class inherits functionality from the parent class. With composition that is a class and other class that implements the desired functionality. In this case in Unreal would be actor and component that implements the desired functionality. Something sometimes we can say actor has a component and this relationship part is really important. Inheritance also has another kind of relationship that we have to follow it and that would be the is a relationship where child class is a specialized version of the parent class. Composition has the same thing that would be the has a relationship. Class implements another class that has the functionality. Actor has a component. For an example, BPPA base has a skeletal mesh component. Uh BP skeleton base implements a skeletal mesh component. So it can have uh a functionality of rendering a 3D model. So what are components? Custom blueprint components first. What are components? Components are special type of objects that actors can attach the themselves as subobjects. There are built-in components like skeletal mesh, static mesh, character movement, sphere collision. All of these things here when we create a character are built-in components. And we can also create our own custom blooping components like an actor component, sync component, so on. Now, so what are custom blooping components? Custom blooping component allows us to create a specific common functionality that can be used on any actor or any class hierarchy. Custom components have an event graph. It can have events, functions, macros, variables, event dispatches, so on and so on. It can basically have all of the things uh actor can have except other components and a construction script. So custom blueprint components where to when to use them they allow us to reuse code on the actors that need that functionality no matter if actors are related or unrelated. So basically unrelated actors they just need to have the component with the desert that desired functionality. So components share common functionality with same implementation which means the code is always the same which means monomorphic events. So this is basically it. Uh so general implementation event is created in run class in with unrelated classes that would be event is created in the custom actor component and code for that uh event is also implemented that same class code for that event is also implemented in that custom actor component. Actor just needs to then have that component for to take that functionality. So composition is sometimes called composition or inheritance meaning that composition is better than inheritance or that is an alternative to inheritance. This just comes from the fact that every actor can have a component no matter the class hierarchy or inheritance. All of the things that BP hazard base class would have and share with SH classes can be done by components. Uh these are all monomorphic events. Uh meaning common functionality with same implementation. Monomorphic functionalities in the parent class can be transferred to monomorphic events inside the actor component. Each functionality becomes its own component. And as we can see it in here, we are basically taking methods from the parent class and transferring them into components. So rotating animation can be replaced with the built-in rotating moment component. Uh floating animation can be replaced with built-in inter moment component. They&#39;re already built in Unreal Engine because they know that many developers will need to have a component for rotating animation basically. And then we have our own custom made userdefined events on damage and damage on condition. We can literally copy them. copy that events and transfer them to newly created custommade actor component that we can call something like manager. We are basically copy and pasting the code but now it&#39;s in the component. Basically now uh there wouldn&#39;t be any kind of methods in the parent class uh and all of the things would be in the components and we wouldn&#39;t need that parent class. Let&#39;s look at this more closely with the animation. So we have this methods that we can transfer into the components. So let&#39;s do just that. on damage and damage condition can be a damage manager. Rotating animation can be rotating movement component and floating animation can be interpretive movement component. As you can see now the parent class has no components, no methods, no variables. Parent class basically uh has nothing. The child classes inherit they inherit nothing. So we can just get rid of the parent class because everything is now in the components. And so now ice needs to have a rotating animation and floating animation. We can just give it the rotating movement component and interpret to movement component. Bomb also needs rotating and floating animation. We can just give rotating movement interp to movement component. And it also needs a damage manager. So on collision it can call on damage event and then destroy the actor. Fire needs a damage manager component. So we can call the damage on position. Cannonball also needs a damage manager component. So we can call the on damage event. And laser needs a rotating moment for rotating animation and damage manager. So it can call the on damage event and spikes need the damage manager as well. So it can call the on damage event. As you can see these are now all totally unrelated losses. Uh they just have the every functionality that they uh have common and they would need to share is now in the component. This is basically the composition using components for sharing common functionalities between unrelated classes. And all of these child classes are unrelated. They all inherit from the built-in actor class. So let&#39;s try and create hazards with composition. So first what we will have to do is uh floating and rotating animation already ex exist as built-in components. So let&#39;s create a damage manager component that from there where we can copy and paste on damage and damage on condition custom events. So creating an actor component is really easy. We just click on blueprint class and select actor component. We will call this damage manager component. And now we just need to copy and paste the code from the BP hazard base. After that uh uh we have all of these unrelated classes that we can create. Let&#39;s take for an example bump. So we have to put all of these components in it. uh so we can have composition. So I will now create a bomb example. We need a static mesh, sphere collision, rotating moment, interpretive moment and damage manager. And as you can see it is a built-in from the built-in actor class. So, we&#39;ll just do that. So, let&#39;s compare BP Hazard Bomb and BP Bomb. BP Hazard Bomb has a BP hazard base as a parent class. BP bomb has a built-in actor class plus. Basically, BP bomb is unrelated actor to any other actor in the level. BP hazard bomb runs animation through methods that inherits from the uh parent class BP hazard base. BP bump on the other hand uh uh runs animation with the help of the components inter to movement component and rotating movement component. And lastly code for on collision is actually the same uh on collision we call the on damage event and then we destroy the actor in the BP hazard bomb and same thing in the BP bomb. Same thing on collision on damage destroy the actor. The only difference is in with the BP hazard bomb that is is a relationship where bomb is a hazard that inherits the own damage for subtracting health. As we can see target is BP hazard base. But for BP bomb that is a has a relationship where bomb has a damage manager component that holds the method on damage for substructing health and that is that relationship for has a relationship. Basically actor has a component for a functionality. Bomb has a static mesh for rendering visual representation. A bomb has a sphere collision for detecting collision. Bomb has a rotating moment for rotating animation. Bomb has an interpation. And bomb has a damage manager. So it can damage the player when the player collides with the bomb. Aka it can call on damage event uh when player collides with the sphere collision component. So now let&#39;s do all of that for all of the other classes. The diagram is right here. So now we just have to get to it. And here we have all of our uh unrelated actors uh that use the on damage event uh rotating moment and interpret moment. So uh we can see that BP bomb has an actor built-in actor class as a parent class. Same thing with fire, same thing with ice, same thing with laser. The only difference is between the inheritance hazards and the composition hazards are that uh the animations are now done with the components and we get the on damage and damage on conditions events from the damage manager component. So let&#39;s look at the difference between BP hazard bomb and BP bomb. BP hazard fire inherits the uh damage on condition while BP fire gets it from the damage manager component. Uh BP hazard ice uh inherits the animations but while ice has the components. BP hazard laser has the animation for rotating and the damage on condition from the parent class while BP laser has a component for rotating and gets the on damage event from the damage manager component. And also uh we can now test this and see what happens. It will be the same thing with the ice. We are frozen for two seconds. With the bomb we lose 20 health. fire uh gets depletes our health with the spikes. We don&#39;t lose health if spikes are not up, but if they&#39;re up, we lose health. With the laser, we lose health as well. And we will get we lose 50 with the cannon, and we also get destroyed because the destroying is happening in the BP level character base. And if you remember, uh the code that manipulates a specific class should be in it class. We are manipulating the player&#39;s health variable. So, we should destroy the player also in the BB level character base. So we have now tested our hazards using composition and as we can see uh we can now add a character which is also unrelated class to all of the others. This is now BPNC enemy something like that and it basically has some controls. I didn&#39;t want to do AI and nav mesh and all the thing. So I hardcoded the overlapping to check if the player is uh in the detection zone and if it is it will chase him and if uh the player overlaps with the damage zone a sphere component or capsule component it will take minus 25. So if I press play and get in the zone, the player will start to chase the enemy will start to chase me and try to hurt me. And as you can see, I got destroyed. And that&#39;s how we can share this damage manager component on all of these unrelated classes. And now every class can damage the player if it has the damage manager component. We have succeeded in finding a way to reuse monu code for monomorphic events between unrelated classes by just using components. Now we need to find a way how to reuse code for polymorphic methods and events between unrelated classes. Right now our interaction system still works with inheritance and beep interact base is uh inherits from the built-in actor class which means all of the ch child chart classes also need to inherit from the built-in actor class. We cannot have unrelated losses. For example, we can now use fire as an interactable because BP fire the deals damage to the damage manager component and has an class of an actor built-in class. We can technically set it as an interactable, but we still cannot add to BP interact base characters because they need to inherit from the built-in character class. Just as we had components uh to share monomorphic events for unrelated classes, we can use blueprint interfaces to share polymorphic events between unrelated classes. So let&#39;s talk about interfaces. Blueprint interfaces. Interface classes are useful for ensuring that set of potentially unrelated classes implement a common set of functions. Interfaces define a set of common behaviors or capabilities that can be implemented by different actor classes. This communication method simplifies the process of implementing the same type of functionality on different actor classes. This method requires each actor to implement the interface in order to access its common functions. Blueprint interfaces add a common functionality to blueprint actors no matter the class or inheritance. So let&#39;s talk about blueprint interfaces as a type of blueprint communication. Interface blueprint communication is only between two actors sender and a receiver. Sender needs to have a reference to the receiver. Only receiver has to implement the interface. Sender does not. It only sends an interface message. Receiver and sender cannot technically access each other&#39;s variables and functionalities like in the direct communication or in the casting when we get that pin for direct communication. Sender only sends an interface message. Receiver if implements that interface defines what that message does. Also there is no error if you send an interface message and receiver doesn&#39;t implement the interface. Okay. So blueprint interface when to use it. Interfaces add a common functionality to unrelated classes. Common in this sense means you are just defining a function name in the interface class. We are not defining the implementation. It&#39;s rent only. Every actor that implements that interface has to then define in their own code what that function name actually does. So interfaces share common functionality with different implementations which means every class has its own implementation for what that event does aka it&#39;s a polymorphic event. So back to our table. So sharing for for sharing polymorphic events we can use interfaces where event is created in one class that would be a interface event is created in the blueprint interface. Code for that event is implemented in multiple different classes. This would be that code for that event is implemented in the classes that implement that implements that desired blueprint interface. So let&#39;s look at a simple example uh of using a polorphic event in the beep interact base. We have created an on interact event which all of the child classes inherit and override to actually define what that on interact event actually does what that interaction does with between these classes. Now uh we want to create this on interact event that can be shared between multiple unrelated classes. We can basically take this on interact event from the parent class and transfer it to the interface interaction class. It&#39;s simple as that. So let&#39;s look at the steps. Right now all of the child classes inherit this on interact event. We can just uh get rid of the BP interact base and now we have three unrelated classes and we want to have an interaction system between them. What we can do is create an interface class called interface interaction. Secondly, we need to create an event uh on interact in the interface interaction class like here. Thirdly, we need to implement the interface on an actor that want to interact with. For example, I want to have an interaction with the BP door. So, I will implement the interface interaction in the BP door class. And lastly, we need to implement the code for what the interaction does with the event on interact. So BP door uh with the on interact event opens and closes the doors. And now we need to repeat the step number three and number four for every actor that we want to interact with. So for BP lamp we will turn on and off the light. For BP TV on interact would turn on and off TV and we can add other unrelated classes for an example NPC. Uh we can add uh we can implement the interface uh interaction and then define on interact event as talking to the NPC. Maybe he can give us quests. We can add a weapons and on interaction we can equip a weapon. We can add clothes and on interaction we can pick up a clothing piece. So on and so on. We basically now have unrelated classes and they share this on interact event by implementing interface interaction. And that&#39;s it. So right now we have three unrelated classes. BP lamp inherits from the built-in actor class. BP door also from the actor class and BP TV also. Now we need to share uh a polymorphic event between these three unrelated classes. Uh we need we can create interface interaction that can share on interact polymorphic event. So first step would be create an interface class called interface interaction. So right click uh in the content browser go to the blueprint and blueprint interface. We will call this interface interaction. [Music] And let&#39;s open it up. Uh second step would be create an event on interact. Okay, on interact. Now this will be an interface event even though it says a functions. Interface is basically a common set of functions to share between unrelated classes. Uh but we will only get an interface function if we have an output to calculate something and get that result in a tick in in an instant. But in this case we will have an interface event because that&#39;s what we need for our interaction system. Uh we can see that it also says read only I cannot put code for our on interact event as it says here cannot create a new nodes in read only graph this comes from the explanation from here interfaces add common functionality to unrelated classes common means you are just defining function name in the interface class I&#39;m just defining the name of this function which is called on interact we are not defining the implementation we cannot it&#39;s read only every actor that implements The interface has to define in their own code what that on interact actually does. That would actually be the step number four. But let&#39;s not get ahead of ourselves. We still have to do step number three which would be implement the interface on an actor that we want to interact with. Okay. Let&#39;s take for an example BP lamp. We need to go to the class settings and here in the interfaces we need to add an interface. In this case that will be interface interaction and let&#39;s compile and save. Always compile the interfa the interface class and the class that you are working with to be sure to get this interfaces on interact event. We can double click it or just get the event on interact. And as you can see it&#39;s also called in here event on interact even though in the interface class we called it just on interact. That way when we see that we have event in front of it, we are uh implementing a class that was not created in that uh class. Basically when we&#39;re talking about polymorphic events uh event is created in the blueprint interface but quote for that event is implemented in BB lamp. The last step would be uh also we can see that event interact comes from the interface interaction and it has an icon of interface basically arrow up a gear and arrow down that&#39;s that icon right here we can be for certain that we are working with an interface event lastly would be implement the code for what the interaction does with the event on interact in the BP lamp uh interaction what it does it uh turns on and off the light so let&#39;s have a flip-flop we will affect a point light component by setting intensity. Uh we will have two intensities. 10,000 will be we are turning on the light and zero will just be turning off the light. Now we have done all of the steps that we want to to interact with our BP lamp. But we also need to have a way to call this event on interact. Now we already have an interaction system. We had an interaction system with our uh inheritance BP interact base. So we can just press an F key, shoot up a line trace and instead of having casting and working with inheritance, we can just call up an interface message. In this case, we just type in on interact and it will say it comes from the interface interaction and on interact. Now this is a message because uh it comes from here. Let&#39;s look at an example. uh sender needs to have a reference to the receiver. Basically, BP playable character base is that sender only receiver has to implement the interface. If we hit with the lanch hit the BP uh lamp, it will implement that interface and it will implement the on interact event which would be turning on and off the light. Then we have sender only sends an interface message. That&#39;s it. Beep in beep level character base from a hit actor only sets an interface message. receiver if implements that interface defines what the message does. If BP lamp uh receives that uh interface message defines that we have to turn on and off the light. If we hit anything else with our line trace uh the there is no error. If you send a message and the receiver doesn&#39;t implement the interface, nothing will happen. But if it does, it will do what that on interface message does. In this case, on interact would uh if we hit the BP lamp, turn on and off the lamp light. So, let&#39;s test and see if this now works. I will press play. And as you can see, nothing happens. Game is not crashing. But if I try to interact with the light, we can turn on and off the light. And as you can see, BP lamp doesn&#39;t inherit from any uh userdefined class. It it is unrelated class and we can interact with it. So now we have to do the same thing with with BP door and BP TV. And it&#39;s really easy to implement our interaction system on new unrelated class. We just need to repeat number step three and four. Implement the interface on an actor that you want to interact with. Okay. BP door. Uh now we just need to go to class settings implemented interface and just call get interface interaction. And the fourth step is uh implement the code for what the interaction does with the event to interact in the BP door. We want to uh open and close the door. And I just copy and paste the code from the interaction class hierarchy for the door. And let&#39;s now put it in the level and test it. And as you can see, I can open and close the doors. And uh now we can go with PPTV. So basically, it&#39;s so easy. Just two steps. Uh so now I can just go and get a custom event on interact and from there I can get the static mesh component that&#39;s because that&#39;s what we are affecting and then uh set the material. If we turn on the TV it will have a material of emission but if we turn off the TV then it will just have a plain old black material. So, let&#39;s have this as target. Compile, save, and put it into the level. And let&#39;s try and interact with it. And when I try to interact with it, it&#39;s not turning on and off. Uh the code is all right. So, what is happening here? Well, uh we have not followed the steps. It says implement the interface uh on actor that want to interact and then implement the code. I have never implemented the interface and I never got any error that I the interface doesn&#39;t work. That&#39;s come from this. There is no error if you send an interface message and receiver doesn&#39;t implement the interface. So what we can do in the BP level character base before calling the on interact we can check if the hit actor does implement interface. This is basically just a debug check uh debug check to check if we implement the if the actor implements the interface and if it doesn&#39;t it can print string that says hit actor does not implement interaction interface. Okay. So now when you uh try to interact with something for example the floor or the doors the doors will open and close what? Oh we actually need to say what interface interaction interface interaction compulsive. And now we will get this when we try to interact with the lamp it will just work with the door it will work but with the BPTV it says hit actor does not implement interface interaction. And then we can say oh right we actually need to implement the interface. Go to the class settings interface interaction compile and then we get the event that we can implement. This step the step number three and four are really easy but we can also forget how to follow them. So it&#39;s always best to have this debugs that we can see. And now we can turn on and off the TV. And now we can implement an interaction functionality to any unrelated class. Which means that now we can actually create an NPC that that inherits from the built-in character class. And now if we want to interact with this NPC, we have to implement the interface interaction. Now compile, save. And we get this event on interact. When a player tries to interact with this NPC, the NPC will say, &quot;Hello, adventurer. Would you like to go on a quest?&quot; Something like that. And now, compile, save. And now when you put this NPC into the level and try to interact with it, we can talk to the NPC. Now, we also wanted to interact with fire. If we added BP fire, we can see that that is an unrelated class to any other actor in the unreal engine. It inherits from the built-in actor class. It can damage the player with the help of the damage manager component from where it can call this damage or condition events. Now I want to interact with fire. If I want to interact with fire, we can go to the class settings and implement an interface interaction. Now the code the functionality for interaction with the fire would be uh uh lighting and extinguishing fire. So we can either extinguish fire and then set the scale for our box collision to zero. So basically we cannot collide with the fire and the fire can hurt us or when we light the fire again then the box collision would be up again. So we can actually overlap with the fire and the fire can damage us again. So let&#39;s test and see how it works. And now when the fire is light up, we are still depleting health. But now when we try to interact with the fire, now we have the steam effect and there&#39;s no box collision. So we are not losing health. But if if I try to inter interact with fire again and light it up, as we can see, we are starting to lose health. Extinguish it again. And that&#39;s it. And now we can interact with the fire or any other unrelated class by just using the interface interaction. Now let&#39;s conclude composition. Uh custom actor components are used for sharing monomorphic events between unrelated classes. With components, we can share count functionality with same combination to any unrelated class. Any monomorphic method that would be in the parent class is now in the custom actor component. Instead of is a relationship where bomb is a hazard that inherits on damage event. Now we have has a relationship where bomb has a damage manager component that holds this on damage event. With interfaces uh we have the that blueprint interface is used for sharing polymorphic events between unrelated classes. With blueprint interfaces we can share common functionality with different implementations to any unrelated class. Any polymorphic method that would be created in the parent class is now created in the blueprint interface. Instead of is a relationship where lamp is uninteractable that inherits uh that inherits on interact event. Now it would be lamp implements interface interaction that gives on interact interface event. Now we can summarize this all in this one table. We have a common functionality with implementation. General implementation for a monomorphic event is that event is created in one class and code for that event is also implemented in that same class. With inheritance that event would be created in the parent class and code for that event would also be implemented in that parent class. Child classes would just inherit or call that event. But if you want to share monomorphic event between unrelated classes, we would create that monomorphic event in the custom actor component. Code for that event would also be implemented in that custom actor component. And now actors that need to have that functionality that need to share this monomorphic event would implement uh that actor component and call or take the functionality from that component. Uh we also have a common functionality with different implementations aka sharing polymorphic events. General implementation is that we created event in one class but code for that event is implemented in different or usually multiple different classes. In inheritance, we would create this event in the parent class, but code for that event would actually be implemented in the child classes. This action is actually called overriding an event in the uh in the inheritance. But if we want to share a polymorphic event between unrelated classes, we would use a uh blueprint interface where event would be created in the blueprint interface, but code for that event uh would be implemented in the classes that implement that desired blueprint interface. And as a disclaimer always we should always use polymorphic events if the functionality does different things between classes and or functionality affects different things between classes. Uh if both of these uh statements are false it&#39;s usually a monomorphic event. So we should use uh for unrelated classes a uh an uh an actor component or just create everything in the parent class if we are using in inheritance. Now uh let&#39;s actually now uh add another unrelated player control pan. Player can now only control character uh and we are using BB playable character base and then child classes can actually be instanced in the level that we can play with BP Manny and BBwin. Let&#39;s add another player control pawn which would be vehicle advance pawn. It will inherit from the uh pawn class and build vehicle pawn class and we would have a vehicle advanced pawn which would have child classes of sports car pawn and off-road car pawn. Uh now this uh vehicle is unrelated class to our characters and the goal for this uh would be that we want to make pickups, hazards and interactables functional with the vehicle class. So everything now that works with our character should now also work with our vehicles. And now we have this vehicle advance spawn that we added to features and content packs. And we selected a vehicle example that was created by Unreal Engine. So let&#39;s actually check it out for a bit. In here we have a vehicle advanced pawn. This is a best class for real vehicle pawns. It handles basic input and camera controls. You can find two examples of specialized vehicle setups in the subfolders. Those subfolders are two. And in here we have two child classes. We have sports caron and off-roon as a child class of vehicle advance pawn. As we can see here we have this code for uh inputs and camera and child classes inherit all of the code. There is no code in the child classes. They inherit all of it. Now uh talking about abstract classes uh vehicle advance spawn is a parent class and abstract class is always a parent class. Secondly, it should actually be defined as an abstract class. So it cannot be instanced into the level accidentally. If I now go to the vehicle advanced pawn class settings, it is actually not generated as an abstract class. This can this could be a problem if I actually choose it as a default pawn class. If I press play, I can move the camera, but I cannot go forward or backwards. And there is of course no visible representation. That&#39;s because we don&#39;t have a skeletal mesh that doesn&#39;t have wheels that vehicle movement component cannot then control to control it. Now it would be better to actually generate as an abstract class. So we don&#39;t get this uh anymore. So now we can just basically uh select sports car pawn and we cannot get vehicle advance pawn in the list or in any way instance it into the level. Now uh secondly it should contain components, variables and methods. It should hold all of the things the child classes will inherit and use. So they all inherit the code but vehicle advance pawn has all of these components and sports car pawn uses them and inherits them and uses them. It actually defines what uh how vehicle movement component should be for for it to be specialized as a sports car sports car in the off car pawn. It uses all of the inherited uh components but also has specialized in such a way that has four five static meshes, four wheels and one uh chassis and uh skeletal mesh is this uh suspension. This is a specialized class that also has a more simulated physics for suspensions. And they&#39;re both specialized in a way that they actually have defined the visual representation. While the abstract class shouldn&#39;t have defined anything that can load something heavy into the memory like visual representation. If I go to the vehicle advance spawn and skeletal mesh, it doesn&#39;t have animation mode. It doesn&#39;t have skeletal mesh asset. Actually, if I look at the size map, it&#39;s literally uh 171 kilobytes. It&#39;s nothing. It only holds and hold holds code and components and child classes are the ones that are actually specialized. Okay, so let&#39;s now get into it. If I want to share a health functionality between two unrelated classes, in this case BP level character base and vehicle advanced spawn, which we could also call BP vehicle base, uh people usually say don&#39;t use casting, use interfaces. So let&#39;s actually see the difference between those two implementation for sharing health functionality. First we will be using casting. We have three requirements. First one is that uh with casting we need to specifically define in the sender class which classes are receivers. Uh in this case we are casting to the BP level character base and calling the art health event. If that fails then we could cast to the BP vehicle base uh and call the art health event from there. We need to cast to every single class that would actually have this health functionality. Second requirement is that casting creates a hard reference to the class when it we are actually casting to and this is especially bad if we are casting to actors that have defined wizard presentation that also gets loaded into the memory. Wizard representation is heavy on the memory like 3D models, visual effects and textures and materials that hold those textures and everything. That&#39;s why we should always cast to the abstract parent classes. They don&#39;t have those visual uh don&#39;t have defined the visual representation and we would also affect the child classes as well. And thirdly, casting uh we need to duplicate variables as you can see right here and events especially if those events have the same implementation. We we can see that we have duplicated health variable uh between the BB vehicle base and B play character base and the event is also duplicated and that&#39;s because casting works with inheritance and it cannot share methods between unrelated classes. We can only duplicate the health variable and duplicate the art health event. As we can see these are two separate and unrelated artalth events. This one is target is BP level character base and for this target is BP vehicle base. We can just duplicate code and every time we want to have another class to have a functionality of health, we would need to go cast failed and then cast to that class that would we want to have that health functionality and then copy and paste the health variable and copy and paste this art health event. Now with interfaces we have a bit different story with inter interface only has two requirements. It needs to imple the class needs to implement interface health modifier to be the BB level character base, BB vehicle base and any other class that we want to have this health functionality. And secondly, we still actually unfortunately need to duplicate health variable and events uh for our add health value event. Now uh but there are more positive things. Uh first positive positive thing is that uh the implementation in the damage manager component is a lot easier. We can just call the atelt value interface message. With interfaces, we don&#39;t need to specify who or what the receiver is. We just need to get a reference and and send an interface message. If the receiver implements that interface, it will call uh its own specific implementation for that value. If the receiver doesn&#39;t implement that interface, nothing happens. So with interface implementation, we got rid of the first two requirements in casting. sender doesn&#39;t need to specify specifically define which classes are receiver. You know, cast to something, cast failed, cast to something else, cast failed, cast to something else and so on and so on. And because of that, we are also not creating a hard reference because we are not casting to them. But the problem still is here. We still need to duplicate the health variable for every class that needs to have a health functionality. And we still need have the same implementation where we need to duplicate this code for the event at health value interface event. So now I have this default pawn class as a sports car. So let&#39;s press play and see what happens. As we can see I am not losing health. I&#39;m not even seeing health. Nothing is happening. Now if I uh go to the vehicle advance pawn I don&#39;t even have a health value v variable. And in the damager manager damage manager component if I click it we are casting to the PP level character base. So of course it doesn&#39;t work because we are not casting to the vehicle advance spawn. So usually what people do now is uh beginners especially go to the cast field and then cast to the vehicle advance spawn and then they will copy and paste this add health event or just like get health if there was get health in it. Now uh casting is not really good for sharing functionalities between our related classes and people usually then say uh to the beginners especially use blueprint interfaces. Don&#39;t use casting use interfaces because blueprint interface communication is better than casting because with interfaces we don&#39;t need to specify who or what the receiver is. We just need to get a reference and send an interface message. Uh we have that actual example in our interaction system from the hit actor. we just send on uh an interface message. It doesn&#39;t matter who that actor is. If it implements the interface and that interface event, it will work. If it doesn&#39;t, no matter nothing happens, it&#39;s okay. So, uh that&#39;s why people say use casting, don&#39;t use casting, use interfaces because it&#39;s easier to call that event. So, let&#39;s actually try and create this example. So, uh we can create a new interface. Uh let&#39;s go blueprint blueprint interface and we&#39;ll call this interface health modifier something like that in it we will have actually we will have this event right here we want to now share this event add health okay so we&#39;ll have this add health uh and I will actually call this at health value so add health value and we will have as as in this event one input which will be a health value. So this will be health value and we&#39;ll have a type of a float. Compile and save. We are done with our interfaces. Now uh we need to uh call this uh interface message in our damage manager component. So instead of having this uh this uh branching logic we can just now delete all of this and from the author actor at health value interface message and health value will be this compile and save. That&#39;s it. Of course now we need to actually implement this at health value to our uh BB level character base which already has the code. We can just now class set. Go to the class settings. Get uh implement this uh interface health modifier. And now we just get add event add health value. And just do this. And now it works. Oh nope. It will be like this. And let&#39;s compile and save. And now uh we need to do the same thing but for our vehicle advance spawn. We can uh now firstly we need to actually if I now paste this we need to actually uh create a new health variable in the vehicle advance spawn because these are two totally unrelated classes. So they need to have their own uh health variables. Of course now we need to actually go to the class settings and firstly implement this interface which is a interface health modifier. And from there we can get the at health value. This is an input and this is like this. We can now delete this. And let&#39;s now test if this works. Uh, of course, let&#39;s actually even print string this in our vehicle. So I will just get the event tick and have this in the vehicle as well. Where&#39;s the tick in here? It&#39;s right here. Okay. And let&#39;s now test this. So first uh let&#39;s test with our uh characters. We have health 100 and when we collide we have 80. So it works. Now we are calling from the uh we are now calling the interface event as we can see in the damage manage component. And now let&#39;s test with the vehicles. If press play and collide with Oh, we we can actually add uh to the vehicle some health. The default value it will be at 300. So now if I press play and collide with the bomb, we lose 20. We have depleting health from the fire. We can now get hurt by the laser and of course with the cannon as well. So now health works for both uh vehicles and player and uh playable characters even though they are totally unrelated by just sharing an event of art health value between them. Now we we were now following don&#39;t use casting use interfaces rule. We created uh an interface class called interface health modifier. Uh we have added the health value. We have created an event add health value and we implement that interface on an actor that want to add health to. So in this case that would be clar base. We implemented the interface health modifier. We created a health variable uh health variable and we created a code that manipulates that health variable. Now we also have via cloud spawn that we want to actually have this health functionality. So we need to implement the interface health modifier. Now we need to create a separate health variable because these two classes are unrelated. And because this we are working with interfaces, we need to have a separate uh implementation for manipulating that health variable. And that is maybe the biggest problem with interfaces using an interface to this at health value functionality because many classes uh health functionality could be utilized by v variety of different unrelated classes. It could be NPCs, enemies, vehicles and so on. And for all of those things we could uh have some form of health and the way they could be damaged. So for all of these things we we would need to repeat the step three and step number four. So implementation creating a health and implementing the code for that health. And same thing for all of these unrelated classes. Now the problem is that all of these classes are are unrelated. We need to create a separate health variable for each for all of those classes. And the code is also actually simple. So we have a because we are just manipulating the health variable by the code of simple addition. The code is all of the same for all of these unrelated classes. As you can see the code is the same. It&#39;s the it&#39;s copy pasted basically and it affects the same thing. It affects the health variable. So what happens if I want to change the code for our health functionality? What if I want to add another input called condition like ignore something like that? we can add another input in our uh in the at health value interface event. Now we need to go to uh now we need to change the code uh so to actually accommodate that condition but we will need to go to all of these separate classes and actually copy and paste this code because the code is has the same implementation for all of these unrelated classes. We are using a blueprint interface aka a polymorphic event to implement a common functionality with same implementation. As you can see, they all have the same implementation. And if we need to create a change, we need to create a change with for each of that separate implementation. We should be using a component that can share that is actually uh better for sharing a monomorphic event between unrelated classes. We should always look at this table. So we need to have a we always need to actually identify what kind of common functionality we have. We now have a common functionality and same implementation. we need to share a monomorphic event. And for to do that for our unrelated classes, we need to use an actor component. An event should only be polymorphic if functionality does different things between classes or affects different things between classes. And uh for that for unrelated classes, we could use interfaces. But in this case, it does the same thing. The code is always the same and it affects the same health variable. So we should not be using a polymorphic event. We should be using a monomorphic event. And to share it between unrelated classes, we can just create uh an actor component something like this. We could create a health manager component and it would have variables such as health and max health and it would have methods like modify health which changes the current value of health variable. It&#39;s it&#39;s the same code of simple addition. But we could also call the second event called check health status. This event basically checks if the health is below zero. So we could have some kind of a death event. we could destroy detector or if the uh health the current health is above the max health. So we can just set the new health as the current max health. We could also have update health or duration which changes the handles gradual changes in health over time uh by using the set time set timer by event and that delay is actually defined as the duration. And lastly, we could have this update health and condition which just handles gradual changes in health based on condition something like uh for where we used the the on damage event for BP5 something like that. So now we would actually use a component for sharing monomorphic events between unrelated classes. In this case this health magic component will give a functionality to any class of having health. So the rule don&#39;t use casting uh use interfaces should be should be something like this. Those you don&#39;t use casting to share functionalities between unrelated classes. Use interfaces for sharing polymorphic events or use components for sharing monomorphic events. So let&#39;s check our health manager component. In here we have modify health event which affects the health variable and the code is just a simple addition. From there we check the call the event check health stars which basically checks if the health is below zero. So we could have some kind of a death event. In this case, it would be just destroying actor or if the health is above the max health. So we can set the new health as the defined max health. We also have update health on condition which just uh gradually changes the health on a condition and update health of duration which gradually changes the health over a duration with the help of the set timer by event where this delay node is actually defining that duration. So let&#39;s look at this. Health manager component gives a functionality of having health to any actor that implements that component. Okay, I want to give this functionality of having health to the BP level character base. So what I need to do is implement that component. So let&#39;s now implement this component in the BP level character base. And in the details panel of this component, I can actually define the default health and max health for our characters. The default health will be 30 or 40 and max health will be 100. So we are not starting at a full health. Now if I press play, we can see that I have this health 100 from this uh health variable in the BP level character base. I don&#39;t care about this health variable anymore in the BB level character base. I only care about the health variable which is in the health manager component. And uh it will basically display the uh actor instance that implements that uh health manager component into the level and the current value of the health. So when I press play, we can see that BP Queen C0 has a health of 40. If I now collide the bomb, I didn&#39;t lose health. If I if I stand on the fire, I&#39;m still not depleting health. And if I try to collide with the laser a few times, the health is still 40. Okay, so let&#39;s see what&#39;s happening. I will now try and edit BP uh BP laser to see what&#39;s up. As we can see, BP laser calls the on damage event which resides in the damage manager component. This other actor is actually our BB level character base that over overlapped with the laser and this it is passed through to the on damage event. So let&#39;s see what&#39;s happening. Oh, we are calling the at health value interface message. So of course we are not affecting the health in the health manager component because we are affecting the health in the BB level character base that implements this uh interface event with this event right here. We are affecting the health inside the vehicle level character base and we are affecting the health inside vehicle advance spawn with this interface event right here. We don&#39;t want to affect this uh two healths in these two unrelated classes. We only want to affect the health inside the health manager component. Okay. So uh let&#39;s think about this. Let&#39;s delete this and uh delete this right here. So health manager component gives a functionality of having health to any actor that implements that component. Then damage manager component&#39;s new functionality should be substracting the health variable from the health manager component. Now when the BP level character base overlaps with the laser, we get this reference right here which would be BP level character base. Now now we need to somehow get the health health variable that is in that B from the health manager component that the BP level character base implements. We can how do we get this component from the BPL character base? We can actually uh call a function called get component by class. Oh, and we need to specify what component that is. That would be the health manager component. And from here we can now uh what usually people do is now this. So we can now access the health variable that&#39;s inside the health manager from the other actor. So BB playable character base from its own implemented component. And if I press play, let&#39;s see what happens. I actually lost health. I have 20 now. And now with the laser, I have 10. I have zero. I have minus 10. I have minus 20, minus 30, so on and so on. I&#39;m a few times I already said there is a rule. The code that manipulates the specific class should be in that class. We are now manipulating this health variable of the health manager component outside of the health manager component. We should call an event uh of the that has this health addition. And if you look at the health manager component, we already have this event. This code right here of addition is the same as in here. But there&#39;s also one more thing with the modify health. We call this check health status which also checks if the health is below zero so we get destroyed. Right now we could actually go into minus and still play the game. So always follow the rule. The code that manipulates the specific class should be in that class. So let&#39;s actually call the event that manipulates this health variable. And if you now connect with this now every time we collide with it we we will still have this code of uh simple addition. But if you get below zero our actor will be destroyed. our character will get destroyed. So, let&#39;s press play and see what happens. I collide with bomb and lose 20. And now I have 20. I have now 10. And now I&#39;m destroyed. As you can see, it&#39;s much better to do it like that. Remember, the code that manipulates a specific class should be in that class. That also I don&#39;t it never says the code that manipulates a specific actor should be in that actor. We are talking about any class even for components that that stands true. Okay. Now I want to talk about something else. This now works. So what is happening when other actor in this case BB level character base overlaps with laser? We call the on damage event which from there says uh let me get the health manager component that is implemented in BB level character base and then call this modify health event which basically substructs health and if that health is is zero we get the owner of that component which is baby playable character base and we destroy him. Now there&#39;s one caveat with this code. Let&#39;s first see if I just change uh this to vehicle advanced game mode for an example. and press play. Now I&#39;m working with vehicles. Nothing important. And I collide with this pump and go back. I have an error. X non trying to read property uh call function get component by class return value modify health blah blah blah damage manager component. What is it saying? Basically uh when when the other actor collided with the laser, I tried to get the health manager component. But the problem is vehicle advance spawn didn&#39;t have this health manager component and there was an error. So we always should actually validate and see if that component actually exist on an actor that has that implemented because now other actor is a vehicle get health manager component. Oh, there is no that help manager component. Let&#39;s crash the game. So we need to stop this crash crashing the game part. So we need to say is valid. This is uh a macro but basically checks if it&#39;s valid or not. And we can now print string and say uh like this. We can even say it like this. get display name. Let&#39;s now test this. As you know, vehicle doesn&#39;t implement this component. And now it says sports car pan doesn&#39;t implement the health manager component. And there was no error. So we should always when we&#39;re telling uh the Unreal Engine, we should always check if the component actually exists. That&#39;s the important part. Uh we have uh same thing with castings. cast to BP anything really. Uh we have this cast failed which is already done for us because this a built-in class. We have to now do this ourselves. Unfortunately, we cannot tell the unrelenting hey get me something and that something doesn&#39;t exist. We have to validate it as well. And we to do that for every time we actually want to get component by class because there could be uh there could be no that component from the uh actor we are trying to access that component from. Now we have to do this same thing for a damage on condition and we will also have damage overtime event. So let&#39;s now test if this works. We have health of 40. And now if you collide with the bomb, we have health 20 and we have also depleting health. And with the laser, we&#39;re losing 10 health. And if we get below zero, we will get destroyed. Everything now works. So what will happen now if our player collides with our pickups? Let&#39;s print strings for uh gold and score variables. Now if we try to collid with the health variable, we will not get any more health because this pickup is affecting the variables in the BP level character base. So we can only affect the score and gold variable. If you look at actually the BP uh BP pickup BP pickup base, we can see that it affects uh the cast the B level character base and then calls the pickup manager function and uh this gold and score variables are actually uh player specific variables and we want to share them between BB level character base and vehicle advance spawn. Now I know that if uh just like with the uh event hat value we had to duplicate code. If I now want to duplicate this code with sharing common functionalities between unrelated classes, I would literally just do this. Copy go to the vehicle advance spawn and then paste uh create golden score variables and then in the BP pickup base we could go cast failed to and then cast to vehicle advanced spawn and from there call the pickup manager there resides there and connect both score variables and it work. As we can see, if we ask ourselves what kind of functionality that is. If you look at the BB level character base and the vehicle advance spawn, the code is the same thing. It&#39;s a simple addition of health, gold, and score variable and also affects the same things. Health, gold, and score variables. This is a common functionality and implementation. We are implementing a monomorphic event. So we can create a new component called player stats manager component which would have variables of gold and score and maybe pickup message and then just have a method on collision with pickup which changes the current value of health gold and score variables. So let&#39;s do just that. So we&#39;ll create a new component called uh pickup player stats manager component. And now let&#39;s open this player stats manager component. Uh as we can see here uh we need to create gold and score variable. So first one will be gold and type of integer and second score. Compile and save. Now uh the event should be on collision with pickup change the current value of health gold and score variables. Okay. So let&#39;s go in here in the big level character base. We already actually have a similar code. So we will just use that and we&#39;ll call this on collision with with pickup. Now we can affect the gold and score variables just fine. Those are the variables specific for our player. But we also need to somehow manipulate the health variable. So it basically player stats manager component manipulates player specific variables of golden score but also player&#39;s health variable that resides in the health manager component. Okay, let&#39;s break this down. So we need to now with the player stats manager component we need to get to the BB playable character base and from the BP level character base we need to uh get to the health manager component that is implemented in the BP level character base. So let&#39;s go one step at a time on the in the this is an example how we can access this in the event begin play I will have a print string now this print string will be special because it will be a of color red and it will play for I don&#39;t know 20 seconds doesn&#39;t matter it needs to be for a long time and uh now we will need to get the owner so I will go uh right click get owner and this is basically a nectar uh that implements this component. So basically if I implement this uh let&#39;s press play and see what happens. There is no print string. Get owner is is basically an actor that implements player stats manager component. If I go to the BV playable character base and now implement player stats manager component. Now when I press play it will also instance this into the uh game and when it begin play it will get the owner the class that implements this uh component which is BP level character base and displayed the display the name of the toner which is BP level character base in this case it&#39;s child class of BPQ C0 an instance of BPQ queen as we can see we can now from the player stats manager component access the DB level character base now we need to access the health manager component And we have already done the similar thing in the damage manager component. So from now when we got the owner our character class and this player stats manage components should be only implemented in the player control pawns like PB level character base and later on vehicle advance pan pawn. We can now get the component and we need to specify which component I want to get the health manager component. So let&#39;s try and get the health manager component from there. And as you can see here, if I now press play, I can actually access BP quincy zero and then health manager component. And that is how we can actually manipulate the health variable that resides in the health manager component specifically implemented in the BP level characterbased class. Okay. So let&#39;s get these two things and we can paste them right here. Now of course we always need to follow the rule the code that manipulates the specific class should be in that class. We don&#39;t want to do this. get component by class and then get health set health and have an addition and that&#39;s it because let&#39;s see what happens if I now have health 80 and collide with the health pickup I will get health of 130 so why is that well uh if we look at the for example health pickup if we edit it we can see it gives health of 50 so of course 80 + 50 is 130 but we have kept uh in the health manager we have something that&#39;s a cap of of max health in BP playable character has that at 100. But because in the uh player status manager component we just would uh have manipulate health variables like this and not call the modify health event we will never have this checkout status and never have this cap of max health. So always and I mean always just uh follow the rule the code that manipulates a specific class should be in that class because then we will actually have this check health status where we can check if the health is below zero or if it&#39;s above max health. So we could set it as max health. So in the player stats magic component remember we always need to validate as well. We might not know if the component is implemented or not. And from there we will just call this modify health event and connect it as a health input because as you can see uh new new new value is uh current value plus some input if modify health event that&#39;s the same code plus a check that we really really want. Okay. Now we also need to call this event. Uh right now uh right now in our BP pickup base, we are still casting the BP level character base and then calling a pickup manager. Now let&#39;s think about this from the other actor. I don&#39;t care if it&#39;s a vehicle advanced spawn or BVP level character base. I only care if it has a player stats manager component because that&#39;s where we are actually manipulating gold score and even the health variable of the health manager component that the player uh has implemented. So in the BPA base only what we actually need to get from the other actor is get the player stats manager component. Oh nope. Oh get component by class. We need to first get component by class and specify that it&#39;s the player stats manager component. Of course, always validate. What if some other actor collides with this that doesn&#39;t have this component? It would be crash the game. So, always validate. And if we have that, we can now call this on collision with pickup event. So, let&#39;s do just that. on collision with pickup and lastly uh in the event graph I don&#39;t want to I want to now print string the golden score variable from the player stats manager component so on the event tick we will have this go it will display the golden score variables while the health manager already displays the health variable. So, let&#39;s see what happens. Now, we have score zero, gold zero, and health 40. We collide with a coin and get one gold and score 20. We get 90 health and score 30. And all of the others work as well. So, this will be our result. We have now health manager component that has the functionality of having health, damage manager component that subtracts that health. And then we have player stats uh component that gives the health that manipulates the health score and gold variables. And as we can see everything works. Now I want to add a new uh type of unrelated player controlled pawn. We&#39;ve just already said that would be vehicles. Let&#39;s delete this interface event. This prints string and this health variable. Now this vehicle advanced pawn is same as when we added it to the game. Now if we want to now give it to have a functionality of having health, all we have to do is just give it a health manager component and then specify the default health. So the default health for this will be a 300 and max health 300 as well. And now let&#39;s compile and save. Now this is a parent class. Child classes will inherit that as well. in the offro sports car one. If you open it up, we can see that inherited that health manager component and inherited the default values of having the health of 300 as we can see right here. Now, it also has an off-road car. It also inherited a vehicle moment uh health manager component and also has a default health of 300. But if you look at the viewport, this is a rigid car. This is car made for the rough environment. It should have actually more durability. So let&#39;s say that this health actually is 400 and max health is 500. Let&#39;s compile and save. As we can see, we can actually uh inherit the components and override the default values in the child classes to make them specialized. This is our car for rough terrains. It has more durability. It has more health. So as you can see, we can now uh override the default values in the components in as well. We can specialize the child classes with the components as well. Now we also need to have a second component. We need to have a gold to manipulate the gold and score uh variable as long as held with our pickups. So that&#39;s this that&#39;s the other uh component comes in player stats manager component. We just need to uh implement this and that&#39;s it. And if you now go to the vehicle advanced game mode and press play. As we can see sports caron uh has health of 300. And if I collide with the bomb we will lose 20 health. We can also have depleting health. Laser can hurt us as well. Cannon has hurt us as well and so on. Now if we go and uh collide with our pickups, let&#39;s see what happens. We get gold one score 20 and we can now replenish Kelt as well and we can pick up all of the pickups. That&#39;s it. It&#39;s so simple. We just need to add two components and everything works. And in the BP level character base, all of these variables and this many of these events are now deprecated. We don&#39;t need them. So let&#39;s clean them up because all of the functionalities only in these two components. Now that we are done with our cleanup, let&#39;s talk about the health manager component. Health manager component gives a functionality of having health to any actor that implements that component. Not only for our player controlled pawns like characters and vehicles, but any unrelated class. It could be items, NPCs, enemies, vehicles, props, any unrelated class that needs to have a functionality of having health. So, let&#39;s actually see that in the in our example. Let&#39;s give a functionality of having health for all for these three interactables. It&#39;s really simple. All we have to do is open a open open up a blueprint, add a health manager component and specify the health and max health for that specific blueprint. For BPTV, that would be health and max health of 20. Now we need to do the same thing for other two interactables. Now we have given a functionality of having held to these three interactables. Now we need to have a functionality somehow to damage somehow that can player damage these uh three actors or any actor that has this scalp manager component. For prototype we could just use a simple line trace. Instead of pressing an F key we could press a left mouse button. And from there uh we could shoot up a line trace that has a purple color. And now we need to from the hit actor we need to somehow access the uh subtract the health from the health manager component. If we remember if I now hit this line with the line chase this TV we need to access this health manager component and we can do that easily by just get component by class and what component that would be that would be a health manager component. Now uh from there we don&#39;t want to now get health set health and so on. we need to follow the rule. The code that manipulates a specific class should be in that class. And we already have the perfect code right here for uh addition and subtraction of health. And also the same event actually checks the health status. So if the health gets below zero, the actor would get destroyed. So let&#39;s actually call this modify health event and health value will be minus 10. Now we should always validate uh when we use this get get component by class uh function we should always validate it because right now without the validation I could now hit this wall and get this error. It basically says when you hit the when this was a hit actor I got the compon tried to get the health manager component by class to get the modify health but this wall actor doesn&#39;t have it so the game crashed basically. So we need to always validate uh if we are getting a component by class. So if the wall for an example doesn&#39;t have it just it would just run this is not valid and everything would be fine. So let&#39;s now actually test and see what happens. We can see that BP TV has 20 health. BP lamp has 30 and uh the door has 50. Now if I shoot this TV twice it got destroyed. Lamp I need to shoot three times and the door is five times. That&#39;s it. this now uh now this code right here here is basically a universal code how we can substract health uh and we uh we don&#39;t want to actually now copy and paste this code every time we want to substract health for every actor and we actually have a solution for that already our hazards all substract substract the health from from the actors that have the health manager component by having a damage manager component now so the functionality of Health manager component is gives a functionality of having health to any actor that implements that component and damage manager component substructs health variable from the health manager component. So instead of having this code right here, what we should do is use code reuse and uh have a damage manager component that can actually reuse the code for damaging. And in here we have this on damage event uh that we can connect it like here other actor is hit actor and health value will be minus 10. And as you can see in here, the code is literally the same. Get component of a class validation and modify health. So in the BP level character base, we don&#39;t need to worry about the validation. We don&#39;t need to be worry about any of that. We just need to implement the damage match component and call this event. So let&#39;s now test if this works. As we can see, it works. And that&#39;s the thing basically health manager components functionality is giving a functionality of having health to any actor that implements that component and damage manager component is has a functionality of substructing health to any actor that implements the health manager component. Now let&#39;s talk about something else in the health manager component. When the health gets below zero we just destroy an actor. And that works for all of the unrelated classes. Even if we add for an example off-road carpon and BP playable charact level character basis child class for an example BP man they would all get destroyed because all of these unrelated classes inherit from the built-in actor class as we can see right here we can destroy any of these actors if we just subtract their health below zero. Now this is a bit boring let&#39;s say this is now just destroy an actor if the health gets below zero. Let&#39;s think about the functionality something like on death event. So what happens when the health gets below zero? They die or get destroyed. Eh, but every single actor dies or get destroyed a bit differently. Now talking about this, uh, character could activate the ragd doll plus disable an input. Vehicle could have an explosion effect, spawn an emitter for class, and then have an impulse from below. So it could jump up and then disable players input. TV could have a cracked screen plus we can spawn some monometer of sparks. A lamp could simulate physics pool plus having flickering lights and so on and so on. So this on that event is this a common functionality with the same implementation. Is this a monomorphic event or a polymorphic event to have a polymorph polymorphic event functionality does different things between classes and functionality affects the different things between classes and that is the case in here. All of these uh actors die a bit differently. they would have different code for death dying on that event. Uh and they affect different things. For example, these have emitters. This this would only affect one static mesh while this would affect static mesh plus uh point light component plus lickering lights. They all die differently. And for that dying differently, they would have different components. So we need to now create a polymorphic event between unrelated classes that is another interface class. So let&#39;s create a new interface class and we will call this interface uh right click blueprint blueprint interface interface death handler something like that. And in here we&#39;ll only have one event on death. Compile save. And now instead of in the health manager when the health gets gets below zero we won&#39;t have this destroy actor. we will get the owner of that class and call this on that interface message. We can just call it and if that class implements the on that event, it will just do it. It will run that uh interface message event. But if it doesn&#39;t, nothing happens. So it&#39;s perfect for us. Now we need to implement this on that event uh to all of the classes that implement the health manager component. So for example, let&#39;s look at TV. Now we will edit BPV and the class settings. We will add a new interface and that will be that handler. We can compile and save. Right here I have already prepared the code for us. So for the set material it will take this screen sec the material right here of the black or emission light screen and it will present it as a cracked material and secondly it will spawn sparks. So now when we have this uh interface event we can now call event on death and connect it like this. And now we need to do this uh same thing for other actors that would have this help manager component. But let&#39;s see what happens if we now inter if we now destroy the TV. We won&#39;t destroy the actor. We will just crack the screen and have the screen uh have sparks. Now we need to do the same thing for the lamp and for the TV. So let&#39;s see what we have done. Now these are all just prototypes. In the B level character base in the skeleton mesh, we only have Z-axis as a non-constrained axis. And this is the collision preset. So we could still have our ragd doll. And basically, we activate this constraints. We disable the input player controller. We launch a character bit into the air and simulate physics. So we could have this rag doll and disabling the input. For the vehicle advance spawn, uh we have an explosion effect which is a spawnter from class. We uh also stop the movement immediately and disable an input and also add all bodies from the below. So we could have this impulse from the below that explosion that makes the core go up. For the BPTV we have the material of cracked screen and then we spawn sparks. For the BP lamp we simulate physics and also add an impulse and we have uh this timeline for flickering lights which sets the intensity that uh for the point light component. And lastly for BP door, we simulate physics only for the static mesh door and also add an impulse and just change a bit of a spawn actor location. So we could actually activate that impulse. After 5 seconds, we stopped simulating physics. So let&#39;s see what happens. Now if I now uh deplete the health from the character, the ragd doll will activate for the car. It will explode. The door will get down. The lamp will also have physics and flickering lights. And the TV will have a cracked screen. Now, the other thing we need to look at it is now let&#39;s see. We can see that these are now dead things, but we can still technically interact with them. And as we can see, we can interact with the lamp, we can interact with this, we can interact with the doors. And not only that, we can still actually call the uh that events. As we can see right here, we can still deplete the health. BPTV health still gets the depleting health even though it should already be that. So, let&#39;s fix this as well. Now, what happens when we try to interact with it? Uh we shouldn&#39;t now go to the branching logic every time we when we on interact and check if the health is below zero. We should check this every time we try to interact with it. So in the BP level character base what we can do is before before we call the on interact event we should check if uh if the uh that hit actor actually has the health above zero. So we can get component by class. It will be a health manager component. We also need to validate if the health manager component exists for that hit actor. So is valid and if it is valid we now can get health. We won&#39;t manipulate the health variable. We will just check if it&#39;s less or equal than zero branch and if that is false then we can interact with this and uh also uh in the uh health manager component on that can only happen once. So we can actually just instead of having a boolean or condition, we can just have a do once uh macro built-in macro in the Unreal Engine. So it can the things can only die once. So we have this macro right here. So if we now test and see what happens now, we can interact with it. But if we destroy the television, as we can see here, uh it cannot die again. Uh, and of course we cannot interact with. Same thing with the lamp. And same thing with the door. Once we actually destroyed it, we cannot interact with the doors or the lamp. And that&#39;s it. They could only die once. Now, let&#39;s test something. What happens if a character collides with the bomb? It will lose 20 health. And what happens if the character collides with the ice? It will uh lose control for two seconds and then it will revert back. Now let&#39;s test the same thing with vehicle advanced game mode. What happens if the vehicle collides with the bomb? It lost 20 health of course because it has a health manager component and it is that component is affected with the damage manager component. But what happens now if we uh vehicle collides with the ice got destroyed but I still have control unlike with the player when I couldn&#39;t control the player for the next two seconds. So let&#39;s see why is that because ice should per freeze our player control pawns and we can see right here why is that we are casting to the character component which BB level character base inherits from and from there we are uh affecting the character movement component by setting the movement mode to none. So of course it cannot affect the vehicle advance spawn that uh that has a vehicle movement component. Okay, so let&#39;s see how can we actually share a common functionality of freezing a player pawn between two unrelated losses. Okay, so now we know that we have unrelated losses, our vehicles and our characters and we need to do something. We need to freeze them for two seconds. Now uh we know that events should only be polymorphic if functionality does different things between classes or functionality affects different things between classes. So let&#39;s analyze freeze portation. What does it do? It freezes a player for x amount of seconds. It freezes a player pawn for x amount of seconds. Okay, no movement to opponent. So, it does the same thing. But what does it affect in the character? It would affect the character movement component. And in the vehicle, it would affect the vehicle movement component plus a player controller. So, that means we are affecting different things and that would be a polymorphic event. We have a common functionality freeze for duration but with different implementations. In the character we are affecting the character movement component. In the vehicle we are affecting the vehicle movement component. So what we can do right now we can create a new interface affect player pawn. And in here uh this this interface will affect player affects visual representation and controls of the player control pawns meaning the characters and our vehicles. So let&#39;s create this new interface. This will be uh right click blueprint blueprint interface interface effect layer on and let&#39;s open it up and our first event will be freeze for duration. Freeze for duration and it will actually have an input of duration and type of float. And now we need to implement this interface on uh our player pawns. That would be VP level character base. We can go to the class settings implemented interfaces. And this will be affect player pawn compile save. And same thing in the vehicle advance pawn class settings player pawn compile and save. Now we have implement this interface in our classes. We already have one interface right here event on that. Uh so we have already implemented some interfaces and that would be the death handler and affect perform. Now let&#39;s see what we have to do. We have to now have this breeze for duration event implemented in both character and the vehicle in the character. We will actually affect the character movement component. So let&#39;s do just that. Now I want to do something before that. I actually want to uh create a new event graph. Now just a disclaimer this is all just one event graph. This is just for organizational purposes but it will have two planes and I will call this interface uh graph and in here I will actually take this event on that and paste it in the interface graph just for organizational purposes nothing more. Uh these are not two separate event graphs. These are just one graph but they are separated in two planes. And from here I will now implement event freeze for duration. As you can see in here we are affecting the character movement component but in the vehicle we will affect the vehicle movement component. Uh but first let&#39;s actually create an interface graph in here as well. And now let&#39;s implement this in BP ice. Instead of having all of this code, we can just from the other actor call the freeze for duration and the freeze for duration will be 2 seconds. And after that we will destroy the actor. Compile and save. And let&#39;s now test this first. We&#39;ll test with the vehicles for the sports caron. It works. I cannot move. And now I can. And now let&#39;s uh test this for the off-road caron. And if we now go with the ice, I cannot move. And now I got the control back. Let&#39;s now test with our characters. First will be queen and cannot move for two seconds and second one will be bp manny and let&#39;s now see I cannot also move for two seconds. So now everything works. Now let&#39;s test something else. What happens when we collide with the bomb? We lose 20 health. But we actually now collided with the bomb. So shouldn&#39;t there be an explosion? So let&#39;s do just that. And now when we actually collide with the with the bomb, there will be an explosion. As we can see, we can actually make this explosion explosion three times bigger. Something like this. So let&#39;s now test this. Yeah, something like that. Now, of course, uh we can see there we we now when you collide with a bomb, there is an explosion and uh we lost health. But there was no impact on our character that it actually collided with the bomb. So maybe that could be our next thing. What would happen be between the uh vehicle and the character when they interact with an explosion? Well, uh we would need to have some kind of visual representation of a physical impact or an explosion. That would be this on impact event. But what does it affect in the character? we would affect the skeletal mesh component by activating the rectal and physics plus disabling plane controller by but in the vehicle we would just have a skeletal mesh component and adding an impulse from below basically uh jumping the car into the air. So let&#39;s do just that. So let&#39;s see what we can do in the interface effect player pawn. We can create a new interface event called on impact that would have one input of a vector type and we could call it an impulse for example. Then we can implement that in the BP bump from the other actor. We just need to call on impact interface message and connect it through the code. And from here we will have an input of just one. Uh that&#39;s more for customizability because now we need to implement this on impact event on both our unrelated player pawns. In the vehicle advance spawn, we will actually take that one on the Z-axis and multiply it by 500 and then call the odd impulse to all bodies below which will make the vehicle just jump into the air. But in the BB playable character, we are actually multiplying it only by 100 and calling another event will function which in this case would be a launch character. But we are doing many more. We are also activating a ragd doll and for that and disabling the player controller. For that we have to first set the constraints only to the Z-axis. We are disabling the input then launching the character then having some kind of a duration and after that simulating physics for the ragd doll and then after 3 seconds while the player is knocked out for an example we revert the controls back. So remove the ragd doll and then reconnect the skeletal mesh to the capsule component. As you can see, that&#39;s much much more complex than just for a vehicle, just from explosion from below. So, let&#39;s now test this with BPQ. And when we uh interact with the bomb, we got the ragd doll. And after 3 seconds, we got the movement back. Let&#39;s now test this with BP Manny as well. And when we press play and now collide with the bomb, same thing. An explosion. And we have a ragd doll knocked down for 3 seconds. Now, let&#39;s test this for our vehicles. Vehicles don&#39;t have a ragd doll. They just will have just an an impact from the below of the explosion as you can see right here. And same thing will be with our off-road car. And that&#39;s it. That&#39;s how this works. Now, on impact can be used not only for explosion bar a, but a physical impact as well. And the question is what would happen if a player pawn gets hit by a cannonball? I am pretty sure that there would be some kind of an impact. So let&#39;s actually add on impact of on our cannonball as well. So this will be on impact and the input will be 1.5 something like that. And let&#39;s now test and see if this works. So when we collide with the cannonball, we will have some kind of an impact. Okay, so this works. Now I want to test something. Let&#39;s see what happens when a character collides with fire. As we can see, it starts to deplete health. And when I step of the fire, the depletion of health stops. Now I want to create an effect where the fire transfers from the ground to the player just like in the GTA games. So let&#39;s see what we can do. We could maybe have a burn effect for duration. It would be a visual representation of the fire and burning effect. After the specific specified duration, the effect would be removed in the character. We would attach this emitter to a capsule component and the emitter would be a fire effect. While the vehicle, it would attach to a skeletal mesh component and it would have a visual effect of smoke or steam. So, how can we do that? In the interface effect player pawn, we could create a burn effect for duration interface event and it would have an input of duration and type float. In the BB level character base, we could attach a fire visual emitter to a capsule component with this uh with this controls where custom time deation would be five for our fire emitter and after some delay we could destroy this emitter. In the vehicle advance pawn the code is actually the same but we are doing doing different things. We are attaching this steam emitter not fire steam emitter to a skeletal mesh component not a capsule component and we have a different control of time deation but after that after a delay we destroy this emitter as well. So now we have to actually implement this burning effect to our fire after we stop colliding with the fire where the fire transfers to the player. So let&#39;s add it BP fire and on component and overlap. Let&#39;s call this burn effect for duration message. And the burn effect will be for 5 seconds for an example. Let&#39;s press play and see what happens. Now when the BP queen stops colliding with the fire, she will have a burn effect for the next 5 seconds. Let&#39;s see if it stops. And now it stopped. Now let&#39;s try this with BP Manny. And let&#39;s collide with fire. And after we stop colliding, the fire effect would follow us for the next 5 seconds, just like in the GTA games, for an example. Now, let&#39;s try this with our vehicles. First, it would be a sports caron. And after we stop colliding with the fire, we will have this steam effect. Let&#39;s see if it stops. And the same thing will be with our uh off-road caron. we step on the fire and when we step out of the fire we will have this steam effect. So now we have a burn effect for for our vehicles and characters. Now let&#39;s try something else. When we collide with the fire, we are depleting health. Of course we are we are standing on fire. We should deplete health. But right now when we have this burn effect for duration, we should also have depleting health while this burn effect for duration uh is active. But we cannot do it because now uh this burn effect is based on a condition and that condition is while we are overlapping with this box collision component of a fire. We are calling this burn uh damage on condition event. But actually we have another event in our damage manager component. Instead of damaging on condition, we could damage some damage our player or anything else over duration. So let&#39;s actually try and implement that in the BP fire. So after we step out of the fire and start this burn effect for duration, we could also actually call a uh damage overtime event where other actor would be other actor. Duration would be 5 seconds just like in the like the burn effect for duration and update interval and health value will be just like the fire in damage on condition. So let&#39;s now test and see what happens. Now when we collide with the fire we are losing health but also now when we step off the fire while we have this burn effect for duration event we are also depleting health as well. So now we have uh something like some this burn effect like in the GTA games. Now let&#39;s see what happens when a player collides with the ice. Now I cannot move for the next two seconds because ice froze our controls. But there is no visual representation that ice ice actually froze us. Uh what if the player thinks there&#39;s some kind of a glitch, there&#39;s some kind of a buck. This is especially true for our vehicles where we actually have acceleration and the acceleration and vehicle is much larger. What happens if a player drives really fast, doesn&#39;t even see an ice cube and then suddenly it stopped immediately stopped and lost control for 2 seconds? Player might think that he uh actually lost the input and that there was some bug in a controller. So, we need to have some kind of a visual representation that the player was frozen and that&#39;s why he cannot move and that&#39;s why he cannot control his player pawn. Maybe we could actually change the material of our skeletal mesh to show that as a visual representation that the player pawn was affected. Maybe we could have a change material for duration event. What does it do? It changes the color of a pawn for duration. After that duration has passed, we revert the materials back to their default materials. In the interface effect player pawn, we could have this event change material for duration with two inputs. The material that&#39;s the input that we want to actually change the material to and the duration that is the duration that our new implement the material will last. After that, the code should uh revert it back to default materials. We also need to think about what does this change material for duration affect in the character. it would affect the skeletal mesh component. It that&#39;s the component for rendering visual representation and in the vehicle it would also affect the skeletal mesh component because that&#39;s the component that renders the vehicle&#39;s visual representation. Now uh because of that uh one thing that we have in the BB playable character base is the skeletal mesh component and as we can see it is not defined that&#39;s the actual specialization of our child classes. BP Manny has a specialization that defined the skeletal mesh as SKM simple while BPQ has a skeletal mesh of queen simple. And these skeletal meshes actually have their own materials. SKM simple has material instance many one and material instance many 2 while BP queen has material instance queen one and material instance queen 2 as their default materials. Now we need to create a code in such a way that if we are playing with BP many it should revert back to material instance many one and two while we are playing with the BP queen it should revert back to material instance queen one and material instance queen two materials. So what we can do in the BB level character base in the construction script we could get this skeletal mesh and get the materials and with the each loop we could save them in the default materials variable that we created. So basically uh now if I connect this if we are playing uh this skeletal mesh could be actually this code will be inherited by the child classes and when we get the skeletal mesh from the child class it will actually be the the skeletal mesh of the child class. So if we are playing with BP queen it would save materialist queen one and materialist queen 2. But if we are playing with BP man it will actually save his material from that SKM uh many simple skeletal mesh. it will be material instance many one and matisense man two. So now we can actually save the variables specific for each child class and for each of their own skeletal meshes. Now we need to actually call this change material for duration. We will have this code in the interface graph and the code is simple. We get the default materials to run a for each loop and this loop will run for the amount for the number of materials that it has. In this case that will be two materials for BP man. Uh and for that array index we will set the new material for for a skeletal mesh as the material we want. Then we have after completed the delay which is actual the duration and after back we have another for each loop and now we are just reverting back back those default materials and setting them back. So basically if we&#39;re playing with BP man, we&#39;re playing with skeletal mesh man simple and then we are reverting back material instance man one and material instance man 2. So let&#39;s actually test and see what happens. Now we are playing with bp manny and we got frozen and we got reverted back to material instance man one and many two. And now let&#39;s try for BP queen. We can also get frozen. And after some time we got reverted back to the materialist squin one and materialist inance squint two. Okay. So now works with our characters. But one thing we need to think about we said that uh what does the change material for duration do? It changes the core of pawn for duration. And we also need to think about what does it affect. In both cases this affects the skeletal mesh component. Thinking about common functionality with different implementations we would to make event polymorphic. the functionality should does something different between classes or functionality affects different things between classes. But in this case, functionality changes the color of the skeletal mesh in both PVP level character base and the vehicle spawn. And it also affects the same thing. It affects that same skeletal mesh. So it actually happens that in the vehicle advance spawn we have the exact same code for uh in our construction script as in the BP level character uh base is the same code just without the print string and actually in the in the interface graph we also have the same code for event change material for the ration literally the same the only difference is that in this uh for example in the vehicle advance spawn it this skeletal mesh will have seven materials instead of two but that it&#39;s the same code and Now uh if I press play, let&#39;s see what happens uh when we actually turn it to the vehicle advanced game mode. We are now playing with the sports car pan. When I press play, let&#39;s see what happens. So the code is copy pasted in the construction script and in the uh in the uh interface graph in our parent class vehicle advance spawn. And when I press play, this is what what will happen. the color actually won&#39;t change. And I was actually thinking, what happened? What just happened? The code is literally the same. It works in the BB level character base. Why doesn&#39;t it work in the in our vehicles? Uh I put all of the code in the parent class vehicle advance spawn. And uh after a bit of testing, the construction script actually doesn&#39;t run at all. If I just put a print string right here, just a print string with hello, and press play, there is no that hello, which actually tells me one thing. the child class of sports carpon doesn&#39;t inherit from the construction scripts parent class and that is actually the case because those weren&#39;t the classes that we created it was from the animal engine they actually overridden the construction script so what we need to do is in this child class tell it that it needs to inherit the parents construction script as well and now when we press play and get frozen now the change material for duration works So we always need to think about if the child class actually inherits the functionality from the parent class like in this case it didn&#39;t until we did this. Now secondly uh let&#39;s now test if uh the same thing for our off-road carpon and let&#39;s see what happens it uh now for off-road carpon I actually did put that construction script inherits the parents construction script so we don&#39;t need to worry about that. And now when we collide with the ice only the suspensions got frozen the chassis and tires didn&#39;t. So let&#39;s see why is that ah we can see right here we are actually affecting the skeletal mesh component. The only difference is that in this case the skeletal mesh component are only this uh suspensions. The this uh body is actually a static mesh called chassis which has four materials and then we have four static mesh tires. Of course, the these things didn&#39;t change the material because they&#39;re not affected by the code. Vehicle advance spawn only affects uh in the vehicle advance spawn change material for duration only affects the skeletal mesh component and that works perfectly because in the offroad caron it change this this thing changes to blue material but we are not affecting chassis tire all of these tires. So we could we should actually use a polymorphic event because we have a specialization in the child classes. Uh so uh we should use a polymorphic event if uh functionality does different things between classes. No, even in the off-road caron the functionality does the same thing. We want to change the material from our uh for our uh visual representation things. But it affects different things. Not only does it need to affect the skeletal mesh component, but these five static meshes as well. And that&#39;s where this comes from. Uh off-road car, what does it affect in the off-road caron? We are we need to affect the skeletal mesh component plus five static mesh components. Uh and now the code is a bit messy. Now this right now this change material furation is an interface event. So how can we uh overwrite an interface event? It&#39;s actually really simple just like normal event would. If we go to the class settings, we can see that implemented interfaces in the off-road car pawn which is a child class of vehicle advanced pawn. There are no interfaces but there are inherited interfaces and we have this interface affect player pawn. We can just get event change material for duration. That&#39;s it. We can implement it from there. As you can see we are have we are actually inheriting the interface events and we can just connect connect it like this. Now this code is actually really and code is horrendous. It&#39;s long and so on but it&#39;s actually really simple. This is literally hard coding uh because this is so down uh skeletal mesh component actually has defined what materials it has unlike in BB level character base and chassis has its own materials. I literally hardcoded the variables uh because if if this class is loaded the variables load them as well. So I have literally hardcoded this code and basically just saying get the mesh and change all the materials to the input. Then get the chassis and change all the materials to input and then get separate tires and change the materials to the input. After the delay, I just revert them back. The code is long. The code is all but it&#39;s actually really simple. We are just hard coding the values because the values are already hardcoded in the meshes themselves because this is a child class and it&#39;s already specialized in a way that has the materials defined. And now finally we actually don&#39;t need to even inherit from the construction script. We can just press play and test if now it works for offered carbon. And it does. And that&#39;s it. And now we are done with prototyping. So let&#39;s see what kind of implementation is the best for each of the game mechanics we have created. Firstly, we will go through a showcase of what we have done, what game mechanic we have created, and why we used a specific implementation for creating that game mechanic. We&#39;ll be adding new functionalities without having to fix the existing ones where one game mechanic doesn&#39;t clash with the ones we made before. We will add more pickups, interactable actors, and hazards. We will talk about drawbacks of inheritance and solutions on how to share common functionalities between unrelated classes. We will look at the difference and similarities in the implementations between unrelated playerc controlled pawns of characters and vehicles. As I said, we want to add new functionalities without having to fix the existing ones. So, we will add a paragon character to the BP playable character class hierarchy to showcase how easy it is to implement a character that we haven&#39;t worked with before. Lastly, we&#39;ll go through a theory cheat sheet with main takeaways that you need to remember. Pickups share their functionality using inheritance. Pickups share a common functionality with same implementation. That same implementation just means that there is only one class that holds all the code. In this inheritance example, that would be the parent class called BP pickup base. The parent class BP pick holds all the code for functionalities that all pickups should have. child classes aka the pickups in the level just inherit that code. The functionalities that all pickups should have are all pickups have a spinning and floating animation. All pickups give some values of health gold and score and all pickups get destroyed after the player collides with them. Class hierarchy that uses inheritance needs to follow the is a relationship where child class is a specialized version of the parent class. All these child classes are specialized pickups. Each child class needs to define a static mesh. As you can see, each pickup has its own 3D model. BP pickup health has a 3D model of health, while BP pickup coin has a 3D model of a coin. Each child class needs to override variable values. That just means that each pickup can give us some values of health, gold, and score. BP pickup health should give us health while BP pickup coin should give us gold. Now every pickup will give us score. So let&#39;s see what happens when we collide with pickups. Now when we collide with BP pickup coin we will get one gold and 20 score. With BP pickup health we will get 50 health and 10 score. Next two pickups are food pickups and they only give us score. Cupcake will give us 100 score while burger will give us 500 score. Coin pouch gives us 20 gold and 200 score. Next, we have an interaction system that uses blueprint interface communication. It has common functionality with different implementations. Common functionality is interaction with an actor, but every interaction is different depending on an actor we are interacting with. The doors open and close. The lamp turns on and off. And the TV turns on and off. This is a common functionality with different implementations because every actor needs to have a different implementation to define what the interaction does. Doors open and close, lamp turns on and off the light. Because we need a different implementation for each actor, we need to use a polymorphic event. And because this com this this functionality needs to be shared between unrelated classes, we use blueprint interface communication. Now these three interactable objects also have a health manager component that is a common functionality with same implementation. Health manager component gives a functionality of having health to any actor that has that component. Player can now damage interactable objects until until their health gets below zero. As you can see, we can damage them with this purple line trace. Now, what happens uh when the uh health gets below zero with these interactable objects. Now, they also implement an interface called interface death handler that defines what actually happens when that health gets below zero. This is a common functionality with different implementations. The common functionality is dying or getting destroyed, but every single actor dies or gets destroyed differently. The doors will get blown out, the lamp falls down, and the light flickers befold before the light bulb burns out and the TV gets a correct correct screen and sparks come flying out. Because we need a different implementation for each actor, we need to use a polymorphic event. And because this functionality needs to be shared between unrelated classes, we use blueprint interface communication. Next, we have hazards. They share their functionality with composition using components. All components share a common functionality with same implementation. All of these hazards are unrelated classes because they couldn&#39;t follow the is a relationship. BP bomb uses a static mesh component for visual representation while BP fire use a particle system component for visual representation. BP bomb use a sphere collision component for detecting collision while BP fire use a box collision component for detecting collision. These are not specialized classes. The only thing that they need to share are events for damaging the player. And it&#39;s better to use a component that we can add to any unrelated class rather than biding the functionality to one class hierarchy. We also have interface affect player pawn. Player characters and vehicles implement interface affect player pawn to show a visual representation of getting affected by the environment or players actions. This is a common functionality with different implementations where the characters and vehicles get affected differently. So let&#39;s test our hazards. When character collides with BPIs, we lose player controller and the material changes to blue to show to the player that he is frozen. We need to change character&#39;s visor representation to the blue so the player doesn&#39;t think there is a bug with their controls. When character collides with the bomb, player loses 20 health and activates a ragd doll. When we collide with the fire, player&#39;s health starts to deplete. And when we step out of the fire, character has a fire visual effect and still loses health while the character is burning. When we step on the spikes, we lose 10 health. When we collide with the laser, we lose 10 health. And the cannonball loses 50 health and activates a ragd doll. Character also has interface death handler implemented. And when character&#39;s health gets below zero, we activate the ragd doll and the player dies. This is the final result. We learned how to add or create a new functionality without having to fix the existing ones where a new game mechanic doesn&#39;t clash with the ones we made before. So let&#39;s add new things so we can see how easy it is to implement new functionalities. Firstly, we&#39;ll start with pickups. To create a new pickup, all we have to do is create a child class from BP pickup base. Then we have to name it. Third step is defining the inherited static mesh component aka the 3D model for our pickup. And last step is defining the value specific for that pickup in the class defaults panel to determine how much health, gold, and score that pickup should give. So let&#39;s create a new pickup. We have to create a new child blueprint class from the BP pick. Then second step is name it. This will be called BP pickup goblet. Third step is to define the inherited static mesh and give it a 3D model of a goblet. I will position it a bit better. Tilt it so it look so it looks a bit more interesting. And lastly, in the class defaults, goblet should give 20 gold and 200 score. That&#39;s it. We have created a goblet pickup. So, let&#39;s create another one. We need to create a child burp class. We need to name it BP pickup apple. Uh it will have a 3D model of an apple. And in the class defaults, it will give us 50 score. And that&#39;s it. We have created a pickup of an apple. So let&#39;s now test and see if this works. We will have an apple and the goblet. As we can see, all of these pickups have spinning and floating animation. Apple will give us 50 score and get destroyed. And goblet will give us 20 gold and another 200 score. To implement a new interactable object, all we have to do is implement the interface interaction on detector and then implement the code for what the interaction does with the on interact interface event. Let&#39;s create a new interactable object. We will create a fan. We can just create a new unrelated blueprint class of an actor. Name it BP fan and add components that our interactable actor needs. In this case, we will need two static mesh components. One is for the base of the fan and the other one is for the blades of the fan. We can position them how we want. To create a new interactable object, we will have to implement the interface interaction and then implement the code for what that interaction does with the help of the on interact interface event. In this case, uh we want to turn on and off the fan. So, we will use a flip-flop node. When the fan is turned on, SM table fan blades should spin. This animation will be created with the help of our timeline. Blade will make 360 rotation for every 2 seconds. This flow track will be connected to the set relative rotation function as an input to the Xaxis. So, let&#39;s now test this. We can put the BP fan into the level and when we interact with it, the fan blades spin. To create a new hazard, all we have to do is add a damage manager component and choose one of the three events that can damage that player. It can be on damage, damage on condition or damage over time. After that, we can call interface message from the interface affect player pawn to show a visual representation of the player pawn getting affected by the hazards. Let&#39;s create a new hazard actor. We&#39;ll create a spinning mace with spikes. We can just create a new unrelated blueprint class of an actor and name it BP spikes mace. Composition is all about components. We will create this functionality using those components. First, we will add a static mesh component to render a visual representation of our maze with spikes. We will add a sphere collision component to detect when player collides with our mace. We will position it around our spiked sphere. We will add a rotating movement component for rotating functionality. And lastly, we will add a damage manager component that holds the methods for subtracting health to any actor that has a health manager component. In this case, that would be our player. In the event graph, let&#39;s add on component begin overlap where we will call the on damage event that resides in the damage manager component. If the player gets hit, we&#39;ll subtract 30 health from the player. We&#39;ll also call on impact interface event from the affect player pawn interface. This event renders a visual representation that the player was hit by something. So let&#39;s now test our new hazard. Now when we collide with the uh spiked ball, we will lose 30 health and activate a rag doll. To add a health functionality to any actor, all we have to do is add a health manager component and define the health and max health values for that actor. And after that, we need to implement interface that handler and implement the code for how the actor dies with on that interface event. Let&#39;s open BP fan blueprint. Firstly, we need to add a health manager component. The health manager component gives a functionality of having health to any actor that implements that component. BP fan will have health and max health values defined as 20. Secondly, we need to implement interface that handler and implement the code for the fan getting destroyed with the help of the on event. In this case, when the fan gets destroyed, we can simulate physics for both static mesh components. That way they can get affected by gravity and receive an impulse. We will also stop the fan blade spinning after 6 seconds if the fan was turned on. So let&#39;s now test this. We can put BP fan into the level. And we can still interact with it with the red line trace, but we can also damage it with our purple line trace. And as we can see, the fan got destroyed. Our interaction system and hazards do not share their functionalities with inheritance. We tried to create an interaction system using inheritance, but the parent abstract class of BP interact base couldn&#39;t share on interact event with unrelated classes. When we wanted to add non-playable character class to our interaction system, the NPC class couldn&#39;t inherit from the BP direct base because th those two classes have a different built-in parent class. As you can see, BP interact base has an actor as a built-in class. You can see right here, native class is actor, while NPC has a character as a built-in class. You can see right here, native class is a character. But now, we can share interaction functionalities between unrelated classes and we can interact with any actor including character classes and NPCs using interface interaction. Same thing happened in hazards. We couldn&#39;t share on damage event with the NPC class because characters also cannot inherit from the parent abstract class of BP hazard base. BP hazard base inherits from the built-in actor class while characters inherit from the built-in character class. But now we have unrelated classes. We can share damage events with damage manager component. Now we can put BP NPC enemy into the level and it can damage the player because it has the damage manager component implemented. We also had an example of fire. If BP fire inherits from BP hazard base, it could damage us, but we could not interact with the fire because it wasn&#39;t a child class of BP interact base. If BP uh fire inherits from BP interact base, we could interact with it, but it could not damage us because it wasn&#39;t a child class of BP hazard base. Inheritance needs to follow the is a relationship. Is a relationship represents a type of relationship where child class is a specialized version of the parent class. Fire can only have one direct parent class. With that parent class, we are determining specialization for our fire actor. Fire can either be a hazard actor or fire is an interactable out actor. Fire can be a child class of BP hazard base and BP interact base at the same time because fire can only have one direct parent class. Now if BP fire is a child class of BP hazard base, it can inherit damage on condition event but we cannot interact with it because it&#39;s not a child class of BP interact base and it cannot inherit the on interact event. Uh secondly, if fire is a child class of BP interact base, it can inherit the on interact event, but uh it cannot damage the player because it&#39;s not a child class of BP hazard base and it cannot inherit damage on condition event. With one of those two parent classes, we are determining specialization for our fire actor following is a relationship. Fire is uninteractable or fire is a hazard. Fire is uninteractable or fire is a hazard. Drawback of the inheritance is that uh it needs to class hierarchy needs to follow the is a relationship and it cannot share functionalities between unrelated classes. BP hazard base and BP interact base are two unrelated class hierarchies and inheritance cannot share functionalities between unrelated classes. while the fire still needs to follow the isa relationship. BP hazard base and BP interact base are two unrelated class hierarchies. Inheritance can&#39;t share functionalities between unrelated classes. That is why our interaction system is created with interface interaction that shares polymorphic events between unrelated classes and that is why our hazards share damage manager component that shares monomorphic events between unrelated classes. Right now, BP fire is an unrelated class. It inherits from the built-in actor class. It can damage us with the help of damage manager component and we can interact with it with the help of interface interaction. We can extinguish fire and we step on it. We cannot get damaged because fire is extinguished. But we can also interact with it and ignite the fire and then we can get damaged when we step on it. This is the final result. We learn how to add or create a new functionality without having to fix the existing ones where a new game mechanic doesn&#39;t clash with the ones you made before. In here, we have created a class hierarchy of characters where BP playable character base is a parent abstract class. While BP Manny and BP Queen are child classes, all of the code is in BP playable character base where BP Manny and BP Queen just inherit that code. BP Manny and BP Queen are data only blueprints. They don&#39;t have any scripts or variables because all of the code is in the parent class. BP playable character base has the code for inputs in the event graph. We have inputs for the moment. This is the already code that Unreal Engine made for us. When we press an F key uh for interaction, it uses a line trace to call on interact interface message. And with the left mouse button, we call on damage line trace that uses a line trace to call the on damage event that resides in the damage manager component. We also have a separate interface graph where we can implement interface events from the interface dead handler and interface affect player pawn. Uh the B level character base has a health manager component for health, player stats manager component that handles pickup functionality and lastly damage manager component where the player can damage other actors. Now player character can pick up pickups, interact with objects and get damaged by hazards. This tutorial wants to teach you how to add or create a new functionality without having to fix the existing ones where one game mechanic doesn&#39;t clash with the ones you made before. Many tutorials only use BP3% character as an example of a player pawn. We will add another unrelated player pawn and share pickup and hazards functionality. We will use a vehicle example and uh from built-in vehicle example that Unreal Engine made for us and uh put it in our game. Now vehicle class hierarchy has a vehicle advance pawn as a parent abstract class while sports car pawn and off-road car pawn are tri classes. All of the code is in the vehicle advance pawn where sports car pawn and off-road car pawn inherit that code. Vehicle advance pawn has a health manager component and a player stats manager component. They also have an event graph for movement and interface graph where we can implement interface event from the interface effect player pawn and interface that handler. We can also pick up pickups and get damaged by hazards with our vehicles. BVP level character base and vehicle advance spawn are unrelated classes. So to share the functionalities of pickups and hazards functionalities between between those two unrelated classes, we need to use components to share monomorphic events and blueprint interfaces to share polymorphic events. Let&#39;s put all new things that we created into the level. Pickups of an apple and goblet, an interactable fan, and spiked mace hazard. This tutorial wants to teach you how to add or create a new functionality without having to fix the existing ones where one game mechanic doesn&#39;t clash with the ones we made before. We know that these game mechanics work with our characters. So, let&#39;s now test them with our vehicles. Vehicle has zero gold and zero score. When we collide with BP pickup goblet, we get 20 gold and 200 score. All other pickups work as well. Vehicle cannot interact with actors, but it can get hurt by hazards. When we get hit by spiked mace, we lost the health and get an impact. When we collide with BP ice, we call freeze for duration interface message where the player loses player controller and stops the movement. Change material for duration changes the material to blue to show to the player that he is frozen. The same thing happens with the character. We are using an interface event because we are affecting different things between unrelated classes. We call freeze for duration to stop the movement. Freeze for duration in the character class affects character movement component while in the vehicle class it affects vehicle movement component. Interface affect player pawn uses polymorphic events. Events should only be polymorphic if the functionality does different things between classes and or functionality affects different things between classes. In here we are affecting different movement components. In the character that would be the character movement component. In the vehicle that would be the vehicle movement component. When the vehicle collides with the bomb player loses 20 health by calling on damage event that resides in the damage manager component. It calls change material for duration to show a visual representation that the player got hurt. As you can see that blink of a red material that&#39;s that visual representation that the player got hurt. It also this change material for duration is actually called in the health manager component and it&#39;s called every time there is a change in the current health value. It also calls on impact event uh where vehicles adds adds an impulse from below when it collides with the bomb while the character activates a ragd doll. As you can see on impact does different things between unrelated classes. Arad doll an impulse w while we are colliding with fire players health starts to deplete thanks to damage on condition event. Uh when we step out of the fire we call damage over time. When we step out of the fire we also call burn effect for duration which spawns a visual effect of burning. As you can see uh car has a smoke effect while player has a burning effect or fire effect. Uh, as you can see, burn effect for duration uh, does different things between unrelated classes. Vehicles have a smoke effect. A player has a character has a fire effect. When we step on spikes, we lose 10 health with on damage event. And we call change material for duration to show a visual presentation that the player got hurt. With the laser, same thing. On damage, we lose 10 health and change material for duration to show a visual representation that player got hurt. Now when cannonball hits us, we lose 50 health with the on damage event and we call change material for duration to show visation that player got hurt. But we also call this on impact where with the character we activate the ragd doll while in the vehicle we activate uh an an impulse from below. Vehicle also has interface that handler implemented. And when vehicle&#39;s health gets below zero, we spawn an explosion visual effect and an impulse from below and change the material to black. Something similar in GTA games. This game mechanics work for off-road car pawn as well because it&#39;s a child class of vehicle advanced spawn. It also gave us an example of overriding an interface event in the child class where we affect not only a skeletal mesh component but five nested static mesh components below the skeletal mesh. As you can see there are no new implemented interfaces but interface effect player pawn is listed in inherited interfaces. Overriding an interface event is same as a custom event. All these functionalities work with BP Many as well because it&#39;s a child class of BP playable character base. This tutorial wanted to teach you how to add a new functionality without messing the existing ones. So let&#39;s add a new character. We will add a readym made character from the Paragon assets. We will add paragon drongo. So let&#39;s make it that all game mechanics that we created work with this new character as well. Firstly, we need to set the parent class as BP level character base. As you can see right away, we got components that were implemented in that parent abstract class. We can remove the original components and just leave the inherited ones. Inherited components cannot be deleted in the child class. So, we don&#39;t even need to worry about deleting something that we should not have to. I will also override the health value in the health manager component to 125. They are compiler errors for movement and we can just delete them because those events will be inherited from the BP level character base. We will only need specialized code that is unique to the jungo character which will leave and this code is for shooting. At the end of the shooting, we will call on damage line trace that is inherited from the BP level character base. The damage will be minus 20. Lastly, we&#39;ll go to the skeletal mesh and create a physics asset so that our rectal doll functionality can work. For drogon&#39;s rectal to work, we need to change on impact interface event in the BP playable character base. I removed the constraints in the skeletal mesh component, but the animations still clashed with the ragd doll. So, I removed animation blueprint at the beginning and reverted the animation blueprint back at the end of the on impact event. So, let&#39;s now test our Dongo character. Dongo is a child class of BB level character base. And all of the mechanics before us should work with this character as well. So, when we collide with this BB pickup goblet, we should get 20 gold and 200 score. With an apple, we should get 50 score. And all of the other pickups work as well. Next, Jungle should be able to interact with actors like turning on and off the fan, opening and closing the doors, turning on and off the lamp, and uh turning on and off the TV. Dongo also inherits damage manager component from the BB level character base and uh calls on damage line trace which is called when we shoot our pistol. So, we can now uh damage other actors as well as you can see right here. Next, Jongo can also get hurt by hazards. For an example, if we collide with this spiked mace, we will lose uh 30 health and activate a ragd doll. Ragdoll is a bit wonky with this character. Uh but what can you do? As you can see, all of these hazards work with Dongo as well. Dongo also has uh inherits that that uh interface that handler and on that event. So when the health gets below zero, we activate a ragd doll. To wrap things up, we will look at the theory cheat sheet that captures all the essential concepts we have covered. This table describes how to implement a functionality. Firstly, we have common functionality with same implementation that shares monomorphic events where the event is created in one class and the code for that event is also implemented in that same class. Inheritance event is created and implemented in the parent class while child classes just inherit or call that event. Sharing monomorphic events between unrelated classes event is created and implemented in the custom actor component while the actor that has that component calls or takes the functionality from that custom actor component. Secondly, we have common functionality with different implementations that share polymorphic events where the event is created in one class but code for that event is implemented in multiple different classes. In inheritance event is created in the parent class but code for that event is overridden in child classes. sharing polymorphic events between unrelated classes where the interface event is created in the blueprint interface. While the code for that event is implemented in the class that implements the desired blueprint interface event should only be polymorphic if functionality does different things between classes and or functionality affects different things between classes otherwise we wouldn&#39;t need to have multiple implementations. Next we have inheritance. We need to know two main things about inheritance. Uh it promotes code reability and it creates a parent child relationship. There is also is a relationship where the child class is a specialized version of the parent class. We need to follow that is a relationship because that&#39;s the only way we can create a proper class hierarchy. Next we have abstract classes. An abstract class is always a parent class. It needs to be defined as an abstract class. So it cannot be instanced into the level. Abstract class should only hold components, variables, and methods. It should hold all things that child classes will inherit and use. That&#39;s because abstract class is still a parent class. It shouldn&#39;t define anything that can load something heavy into the memory. Usually, visual representation is heavy on memory like 3D models, visual effects, sound files, and especially textures and materials that hold those textures. This class doesn&#39;t have a visual defined visual representation and because of that it&#39;s invisible. The methods and variables are usually also undefined or just zero or none. That&#39;s why we need to uh define it as an abstract class. So it cannot be instantly level because that would be an invisible actor that gives nothing. Next we have casting. Casting works closely with inheritance. You should always cast to an abstract class. We can create an event in the abstract class and then call that event from another class. By casting to an abstract class, we can manipulate all child classes with that inherited event, whether the child class just inherits it or overrides it. If you cannot work with inheritance, then don&#39;t use casting. If inheritance cannot share common functionality between classes, casting becomes hard to work with. Casting chains become a problem when you want to share a functionality between unrelated classes. As you can see right here, we had this problem when we worked on an interaction system using inheritance. BP NPC base and BP hazard fire could not be a part of in the interaction class hierarchy. Because of that, we needed to create separate on interact event and have separate casts and calls in the BB playable character base. Next, we have is a relationship. We should only create class hierarchies using inheritance following the is a relationship. Following the is a relationship, we get the rule child class is a specialized version of the parent class. In here, we have an example of the animal class hierarchy where the animal is a parent class to the dog and the bird. But each child class has its own child class. Dog has a poodle as a child class while bird has a pigeon as a child class. Following the is a relationship, we could say poodle is a dog and dog is an animal. Same thing. Pigeon is a bird. Bird is an animal. The whole class hierarchy needs to follow the is a relationship. That is the only way we can create a functioning class hierarchy. A child class is a specialized version of the parent class. The poodle is a specialized type of dog and the dog is a specialized type of animal. The pigeon is a specialized type of bird and the bird is a specialized type of animal. A child class can only be specialized version of the parent class if it inherits and uses functionalities from the parent class that includes components, methods and variables. If we don&#39;t follow the is a relationship, managing class hierarchies becomes a problem. Next, we have steps for creating a class hierarchy that follows the is a relationship. First step is determining the main theme of the class hierarchy. So basically, what kind of functionality or game mechanic do we want to create? is the pickups, hazards, characters, interactables, animals, weapons, cars, clothing, NPCs, so on and so on. This first step actually determines the specialization of that class hierarchy, aka the game mechanic that we want to create. Second step is identifying common features for this functionality. We can just basically describe it, use bullet points or something else. For example, we can describe pickup functionality using bullet points. All pickups need to have spinning animation. All pickups need to have floating animation. All pickups need to get destroyed after the player collides with them. And all pickups should give to the player some value of health, gold, and score. That&#39;s the description for our pickup game mechanic. Third step is creating a parent class for that functionality. We are basically creating an abstract parent class and writing down potential components, variables, and methods that all child classes would inherit because it&#39;s implemented in that abstract parent class. We can return to this step after going through steps four, five and six. Fourth step is coming up with potential child classes. Basically writing down a list and in that list we also need to write down which specific components will each child class need and which specific functionalities will each child class need. Fifth step is comparing the components of our potential child classes. It is referring to the first bullet point of the fourth step. Do all of the potential child classes share the same component? If they do, we can then add it to the after class and all of the child classes will inherit that component. If they don&#39;t, then we can add it to the child class that needs that component. Sixth step is do they all share a functionality? What does it do and what does it affect? This is referring to the second bullet point of the fourth step. Which specific functionalities will each shell class need? Now in the sixth step, we need to watch out if it&#39;s a monomorphic event or is it a polymorphic event. If it&#39;s a monomorphic event, then we can create and implement the event in the abstract class. But if it&#39;s a polymorphic event, then we just create an event in the abstract class and override it in the child classes. And that&#39;s it. When we go through this 64 step, we can actually see what will be the in the abstract class that all of the child classes would inherit and what kind of things we need to override in the child classes to make them specialized version of the parent class. Next we have related or unrelated classes. We need to find the first shared parent class to find the relation between two classes. Let&#39;s look at the animal example. Poodle is a dog. Dog is an animal. Pigeon is a bird. Bird is an animal. But pigeon is not a dog. To find the relation between these two classes, we need to find the first shared parent class. The first shared parent class between pigeon and a dog is an animal parent class. They are only related by being animals and that&#39;s following that is a relationship because both pigeon is an animal and dog is an animal. Classes are only related if they have a userdefined class as the first shared parent class. So let&#39;s look at an example. We have here we have BP Manny and BP Quinn that inherit from the built-in character class. In this case, BB Manny and BB Queen are duplicated character classes. BP Manny and BPQ Queen are unrelated because first shared parent class is a built-in character class. On the other example, we have BP playable characterbased abstract parent class to BP Manny and BP Queen. In this case, BP Manny and BB Queen are related because first shared parent class is a userdefined BB playable character base class. It&#39;s a class that we actually created and then from it create child classes. We create a new unrelated class every time we create a new blueprint class. So basically when we have this window pick parent class and then choose actor pawn character and so on and so on. So every time we choose this they inherit from the built-in actor pawn or character class and they are unrelated to any other class that we created. Only if we from the created class user defined class uh we create child classes then those child classes will be technically related because uh we cannot actually uh create our own functions or events or variables in the built-in classes. We can only access them or call them. Now let&#39;s talk about drawbacks of inheritance. This is a rule but it is also a drawback to create to proper class hierarchy needs to follow is a relationship where child class is a specialized version of the parent class. So if you want to create a class hierarchy we need to follow the is a relationship. But it can happen that we cannot actually follow it. And if we cannot create a class hierarchy that follows the is a relationship we cannot then share that functionality with inheritance. It&#39;s over basically we cannot use inheritance. There is also that inheritance can only share common functionalities between related classes. Only a parent class can share functionalities to its child classes. If a class cannot be a child class of that class hierarchy, it&#39;s over. We cannot use inheritance again. For an example, we had BP uh BB fire wants to be a hazard and an interactable at the same time. We cannot do that. Next, we have class responsibility. The code that manipulates a specific class should be in that class. If one class needs to change another class&#39;s variable, it should call an event. It should not set others variables in the event graph. This is an example of what we should not do. On damage event gets component by class. That component is a health manager component. We get and set the health outside of the health manager component. And we are basically manipulating the health variable. We should not do that. Instead of that, we should call an event that keeps code in one place and it&#39;s easily expandable. So we should uh instead of getting and set the health, we should call modify health event that resides in the health manager component. Modify health also manipulates the health variable. But we can also expand it to call another event check status. Check health status checks if the health is below zero. So it can call on that event or if the health is above max health value. So it can just set the current health as a max health. Now let&#39;s look at this on damage receives an input of minus 20. The health is processed and let&#39;s say that now health is minus5. So it&#39;s below zero. It will call a check health status and see that new health is minus uh below zero. It will call on that event. If we have the previous code that we have here, the health will just get below zero. It will be minus five and that&#39;s it. There will be no that event because we are not calling it. But if we are having an event, we can keep it in one place and we can always expand it. So the code that manipulates a specific class should be in that class. Next we have composition. Custom actor components are used for sharing monomorphic events between unrelated classes. With components, we can share common functionality with same implementation to any unrelated class. Any monomorphic method that would be in the parent class is now in the custom actor component. Instead of is a relationship where bomb is a hazard that inherits on damage event, now it&#39;s has a relationship where bomb has a damage manager component that holds the on damage event. Next, we have interfaces. Blueprint interface is used for sharing polymorphic events between unrelated classes. With blueprint interfaces, we can share common functionality with different implementations to any unrelated class. Any polymorphic method that would be created in the parent class is now created in the blueprint interface. Instead of is a relationship where lamp is an interactable that inherits on interact event. Now it&#39;s lamp implements interface interaction that gives on interact interface event. And lastly we have this flowchart that tells us when and which implementation we should use. I need to create a common functionality. Now we need to answer this first question. Is it shared between different class hierarchies? If the functionality needs to be shared only in one class hierarchy like pickups, characters and vehicles, we can use inheritance. If we need to share that functionality between unrelated classes, then we need to determine if the implementation is the same for all of these unrelated classes. If it is, then we can use custom actor component that shares monomorphic events. If we need different implementations, then we can use blueprint interface that shares polymorphic events. And by following this flowchart, we can create a common functionality. So what to learn next? After this tutorial, you could learn about gameplay framework, game rules, characters, controllers, user interfaces, and all of the other built-in classes in the Unreal Engine that make up the framework for the game. We talked about how built-in actor class hierarchy works, but there are many more built-in classes in the Unreal Engine that help us in creating games. For an example, how can we control a widget between unrelated player control pawns of characters and vehicles? Let&#39;s look at this game mode example and how classes work between them. Player controller is a class that is responsible for a hut class. Widgets were managed by a hat class in the Unreal Engine 4, but it&#39;s kind of deprecated today. And the player controller itself took the role for managing widgets. We can see the official vehicle example uh and how they manage widgets. Vehicle player controller also runs widget blueprints with the player controller class itself. So we are not using HUD anymore. Player controller itself manages those widgets. I will just run through a quick example of how we could implement and manage a widget between unrelated player control pawns of characters and vehicles. We can create a player controller base that adds a widget of UI player stats to the viewport. The widget displays health, gold, and score values. Child classes, vehicle player controller, and playable character player controller inherit parents begin play. As you can see, inheritance is an important part in the Unreal Engine development. In the vehicle advanced game mode, we assign vehicle player controller as a player controller class. Same thing for BP thirdp person game mode where playable character player controller is a main controller for that game mode. UI player stats widget has a render player stats event that updates the current values of health golden score. It is called when the widget is constructed and when we call update player stats event that is created and implemented in the player controller base. We also update player stats event in the pickup manager and health manager component. That&#39;s because player controllers manage user interfaces. As you can see, uh player controllers manage widgets. We get the player controller we cast to the player controller base and call update player stats. Update player stats uh calls render player stats that resides in the UI player stats uh widget. And that widget just updates uh the current values of health, gold, and score. You could also learn about event dispatchers. They are also a type of blueprint communication. In our example, instead of using interface that handler and on that interface event, we could use on that event dispatcher. Let&#39;s see how we could implement something like this. In the health manager component, a component that uh gives a functionality of having health and managers health. we can create on that event dispatcher that is called when the health gets below zero in the actors uh that have this health manager component. We can just rightclick add an event and add on that event dispatcher. We will get an event like this and the implementation is same as it would be with our in on that interface event. Now this event is really similar to our collision components uh where we get on component begin overlap. This is the same kind of an event. Now big disclaimer event dispatchers are not same as blueprint interfaces. It just so happens that this that functionality can have an alternative but that will not always be the case. Blueprint interfaces and event dispatchers are completely separate things and they are different types of blueprint communication. Now also managing event listeners can become a great pain. So take your time learning event dispatchers. There is also datadriven design. Uh instead of using inheritance and data only blueprints, we could use data assets for example for your creating pickups. There are also data tables, gameplay ts, structures. They all provide a different kind of way of developing a functionality. For datadriven design, soft references are also a good thing to know. As you can see, this was just an introduction to object-oriented programming. We have just scratched a surface of many different ways we could create games using Unreal Engine 5 program. And lastly, please click the link below for a short anonymous survey that only takes a few minutes to complete. I needed the data from this survey to complete this college project. I hoped you enjoyed this tutorial and found it helpful. And of course, thank you for watching.</p>
